<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>å®æ—¶è¯­éŸ³è½¬å†™ + ç¿»è¯‘ Â· iPad å¹³æ»‘æ¨¡å¼</title>
<style>
  :root{--bg:#0b1020;--panel:#111936;--text:#e7ecff;--muted:#93a4c3;--line:#1f2a4d;
    --brand:#7c9dfc;--ok:#22c55e;--warn:#f59e0b;--danger:#ef4444;--shadow:0 20px 50px rgba(3,8,23,.4)}
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b1020,#0f1530 60%,#0b1020);color:var(--text);
       font:15px/1.6 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
  .card{background:linear-gradient(180deg,#0f1633,#0e1630);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)}
  .header{padding:16px 20px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center;justify-content:space-between}
  .title{font-size:18px;font-weight:700;letter-spacing:.2px}
  .pill{border:1px solid var(--line);color:var(--muted);padding:4px 8px;border-radius:999px;font-size:12px}
  .body{padding:16px 20px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:12px 0}
  .row > *{flex:1}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input,select,button,textarea{background:#0b122b;border:1px solid var(--line);color:var(--text);
    border-radius:10px;padding:10px 12px;outline:none}
  input::placeholder{color:#6b7280}
  select{cursor:pointer}
  button{cursor:pointer;transition:.15s ease;border:1px solid #2a3870}
  button.primary{background:linear-gradient(180deg,#4f6df7,#4a61e6);border:none}
  button.ghost{background:#0b122b}
  button:disabled{opacity:.6;cursor:not-allowed}
  .btns{display:flex;gap:10px;flex-wrap:wrap}
  .status{font-size:13px;color:var(--muted)}
  .log{background:#0b122b;border:1px dashed #213069;border-radius:12px;padding:12px;height:140px;overflow:auto}
  .preview-wrap{position:relative;margin-top:6px}
  #preview{width:100%;height:560px;resize:vertical}
  .copy-fab{position:absolute;right:8px;top:8px;background:#101a3b;border:1px solid #2a3870;border-radius:8px;padding:6px 10px;font-size:12px}
  details.settings{margin:14px 0;border:1px solid var(--line);border-radius:12px;overflow:hidden}
  details.settings[open]{box-shadow:var(--shadow)}
  details.settings summary{list-style:none;cursor:pointer;background:#0d1534;padding:12px 14px;display:flex;align-items:center;gap:10px;
    user-select:none;border-bottom:1px solid var(--line)}
  details.settings summary::-webkit-details-marker{display:none}
  .chev{width:10px;height:10px;border-right:2px solid #7c9dfc;border-bottom:2px solid #7c9dfc;transform:rotate(-45deg);transition:.2s}
  details.settings[open] .chev{transform:rotate(45deg)}
  .controls{padding:14px;display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  @media (max-width:1000px){.controls{grid-template-columns:1fr}}
  .small{font-size:12px} .muted{color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="header">
      <div class="title">å®æ—¶è¯­éŸ³è½¬å†™ <span class="pill">iPad å¹³æ»‘æ¨¡å¼ Â· å®æ—¶ç¿»è¯‘</span></div>
      <div class="status" id="status">æœªè¿æ¥</div>
    </div>

    <div class="body">
      <!-- é¡¶éƒ¨æ ¸å¿ƒè¾“å…¥ -->
      <div class="row">
        <div>
          <label>OpenAI API Keyï¼ˆæœ¬åœ°è°ƒè¯•ç”¨ï¼›çº¿ä¸Šæ”¹ä¸ºåç«¯ç­¾å‘ä¸´æ—¶å¯†é’¥ï¼‰</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
        </div>
        <div>
          <label>Realtime ä¼šè¯æ¨¡å‹</label>
          <select id="rtModel">
            <option value="gpt-4o-mini-realtime-preview-2024-12-17" selected>gpt-4o-mini-realtime</option>
            <option value="gpt-4o-realtime-preview-2024-12-17">gpt-4o-realtime</option>
          </select>
        </div>
        <div>
          <label>è½¬å†™æ¨¡å‹</label>
          <select id="sttModel">
            <option value="gpt-4o-mini-transcribe" selected>gpt-4o-mini-transcribe</option>
            <option value="gpt-4o-transcribe">gpt-4o-transcribe</option>
          </select>
        </div>
      </div>

      <!-- å¯æŠ˜å å‚æ•°ï¼ˆé»˜è®¤æ”¶èµ·ï¼‰ -->
      <details class="settings">
        <summary><span class="chev"></span><b>å‚æ•°è®¾ç½®ï¼ˆå¯æ”¶èµ·/å±•å¼€ï¼‰</b><span class="muted small"> Â· æ¨¡å¼/ç¿»è¯‘</span></summary>
        <div class="controls">
          <div>
            <label>æ¨¡å¼</label>
            <select id="mode">
              <option value="ios" selected>iOS å¹³æ»‘ï¼ˆæ¨è iPadï¼‰</option>
              <option value="smart">æ™ºèƒ½ï¼ˆæœ¬åœ° VADï¼‰</option>
              <option value="fast">ä½å»¶è¿Ÿï¼ˆå›ºå®šé—´éš”ï¼‰</option>
            </select>
          </div>
          <div>
            <label>è¯­è¨€æç¤º</label>
            <select id="langHint">
              <option value="">Auto</option><option value="zh" selected>ä¸­æ–‡</option>
              <option value="de">Deutsch</option><option value="en">English</option>
              <option value="ja">æ—¥æœ¬èª</option><option value="fr">FranÃ§ais</option><option value="es">EspaÃ±ol</option>
            </select>
          </div>
          <div>
            <label>å›ºå®šé—´éš” msï¼ˆä½å»¶è¿Ÿæ¨¡å¼ï¼‰</label>
            <input id="commitMs" type="number" min="300" max="2000" value="650" />
          </div>

          <!-- â€”â€” ç¿»è¯‘ â€”â€” -->
          <div>
            <label>å®æ—¶ç¿»è¯‘</label>
            <select id="translateOn">
              <option value="on" selected>å¼€å¯</option>
              <option value="off">å…³é—­</option>
            </select>
          </div>
          <div>
            <label>ç›®æ ‡è¯­è¨€</label>
            <select id="translateTarget">
              <option value="auto" selected>è‡ªåŠ¨å¯¹å‘</option>
              <option value="zh">ä¸­æ–‡</option><option value="de">Deutsch</option><option value="en">English</option>
              <option value="ja">æ—¥æœ¬èª</option><option value="fr">FranÃ§ais</option><option value="es">EspaÃ±ol</option>
            </select>
          </div>
          <div>
            <label>è¿‘å®æ—¶é¢„è§ˆç¿»è¯‘</label>
            <select id="nearRealtime">
              <option value="on" selected>å¼€å¯ï¼ˆè¾¹è¯´è¾¹å‡ºä¸´æ—¶è¯‘ï¼‰</option>
              <option value="off">å…³é—­ï¼ˆåªå¥è½åœ°è¯‘ï¼‰</option>
            </select>
          </div>
        </div>
      </details>

      <!-- æ§åˆ¶æŒ‰é’® -->
      <div class="row btns">
        <button class="primary" id="btnStart">å¼€å§‹</button>
        <button class="ghost" id="btnToggle" disabled>æš‚åœ</button>
        <button class="ghost" id="btnStop" disabled>åœæ­¢</button>
        <button class="ghost" id="btnCopyPreview" disabled>å¤åˆ¶é¢„è§ˆæ–‡æœ¬</button>
      </div>

      <!-- å®æ—¶æ–‡æœ¬é¢„è§ˆ -->
      <label>å®æ—¶æ–‡æœ¬é¢„è§ˆï¼ˆåŸæ–‡ + è¯‘æ–‡ï¼›è¯‘æ–‡è¡Œåè‡ªåŠ¨ç©ºä¸€è¡Œï¼‰</label>
      <div class="preview-wrap">
        <button class="copy-fab" id="btnCopyFab">å¤åˆ¶</button>
        <textarea id="preview" class="mono" placeholder="å¼€å§‹åï¼Œè¿™é‡Œå°†æŒç»­æ˜¾ç¤ºé•¿å¥ï¼ˆiPad å¹³æ»‘å¤„ç†ï¼‰â€¦"></textarea>
      </div>

      <p class="muted small">iPad å¡çŸ­å¥ï¼Ÿä½¿ç”¨â€œiOS å¹³æ»‘â€æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰ï¼Œè¯¥æ¨¡å¼ä»…ç”¨æœåŠ¡ç«¯ VADï¼Œå¹¶ç”¨é™é»˜å®šæ—¶èšåˆ â‰¥1.3s æ‰è½åœ°ã€‚</p>

      <label>ç³»ç»Ÿæ—¥å¿—</label>
      <div class="log mono small" id="log"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const log = (msg, cls="") => { const p=document.createElement("div"); p.textContent=msg; if(cls)p.className=cls;
    $("log").appendChild(p); $("log").scrollTop=$("log").scrollHeight; };
  const setStatus = (txt) => $("status").textContent = txt;

  // WebRTC / Realtime
  let pc=null, dc=null, micStream=null, micTrack=null, ac=null, analyser=null, rafId=null;
  let ephemeralKey=null, paused=false, fixedTimer=null;

  // æ–‡æœ¬ + ç¿»è¯‘èšåˆ
  const finalPairs = []; // [{src, tgt}]
  let liveSrc=""; let liveTgt="";
  let liveTransDebounce=null, liveTransReqId=0;

  // é™é»˜å®šæ—¶å™¨ï¼šæ— æ–°å­— >= holdMs æ‰ finalizeï¼ˆiOS å¹³æ»‘æ ¸å¿ƒï¼‰
  let silenceTimer=null;

  // å¹³å°æ£€æµ‹
  const isIOSUA = /iPad|iPhone|iPod/.test(navigator.userAgent)
    || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);

  // é…ç½®
  let cfg = {
    apiKey:"", rtModel:"", sttModel:"", mode:"ios", langHint:"",
    translateOn:true, translateTarget:"auto", nearRealtime:true,
    commitMs:650, // fast æ¨¡å¼ç”¨
    silenceHoldMs: 1300, // iOS å¹³æ»‘ï¼šé™é»˜è½åœ°é˜ˆå€¼
    iosMic: { channelCount:1, noiseSuppression:false, echoCancellation:false, autoGainControl:false, sampleRate:48000 }
  };

  // é¢„è§ˆï¼šè¯‘æ–‡è¡Œåç©ºä¸€è¡Œ
  const updatePreview = () => {
    const lines = [];
    for (const pair of finalPairs) {
      if (pair.src) lines.push(pair.src);
      if (cfg.translateOn) { lines.push("ã€è¯‘ã€‘" + (pair.tgt ?? "(å¤„ç†ä¸­â€¦)")); lines.push(""); }
    }
    if (liveSrc) {
      lines.push(liveSrc);
      if (cfg.translateOn && cfg.nearRealtime) { lines.push("ã€è¯‘Â·ä¸´æ—¶ã€‘" + (liveTgt || "â€¦")); lines.push(""); }
    }
    const full = lines.join("\n").trim(); // è‹¥éœ€æ–‡æœ«ä¿ç•™ç©ºè¡Œï¼Œå»æ‰ .trim()
    const el = $("preview");
    const stayBottom = (el.scrollTop + el.clientHeight + 8 >= el.scrollHeight);
    el.value = full;
    if (stayBottom) el.scrollTop = el.scrollHeight;
  };

  // æŒ‰é’®
  $("btnStart").onclick = start;
  $("btnToggle").onclick = togglePause;
  $("btnStop").onclick = stopAll;
  $("btnCopyPreview").onclick = copyPreview;
  $("btnCopyFab").onclick = copyPreview;

  async function start(){
    cfg.apiKey   = $("apiKey").value.trim();
    cfg.rtModel  = $("rtModel").value;
    cfg.sttModel = $("sttModel").value;
    cfg.mode     = $("mode").value;
    cfg.langHint = $("langHint").value;
    cfg.translateOn     = $("translateOn").value === "on";
    cfg.translateTarget = $("translateTarget").value;
    cfg.nearRealtime    = $("nearRealtime").value === "on";
    cfg.commitMs        = parseInt($("commitMs").value||"650",10);

    if(!cfg.apiKey){ alert("è¯·å…ˆè¾“å…¥ OpenAI API Key"); return; }

    // iPad é»˜è®¤è‡ªåŠ¨åˆ‡æ¢åˆ° iOS å¹³æ»‘
    if (isIOSUA) { cfg.mode = "ios"; }

    disableAll(true); setStatus("å‡†å¤‡ä¸­â€¦"); log("â–¶ï¸ Start clicked");

    try{
      // 1) ä¸´æ—¶å¯†é’¥
      const sessResp = await fetch("https://api.openai.com/v1/realtime/sessions", {
        method: "POST",
        headers: { "Authorization": `Bearer ${cfg.apiKey}`, "Content-Type":"application/json", "OpenAI-Beta":"realtime=v1" },
        body: JSON.stringify({ model: cfg.rtModel })
      });
      if(!sessResp.ok){ throw new Error("è·å–ä¸´æ—¶å¯†é’¥å¤±è´¥: " + await sessResp.text()); }
      const sess = await sessResp.json();
      ephemeralKey = sess?.client_secret?.value;
      if(!ephemeralKey) throw new Error("æœªæ‹¿åˆ°ä¸´æ—¶å¯†é’¥");
      log("âœ… ä¸´æ—¶å¯†é’¥å·²è·å–","ok");

      // 2) WebRTC + DataChannel
      pc = new RTCPeerConnection();
      const audioEl = new Audio(); audioEl.autoplay = true;
      pc.ontrack = (e)=>{ audioEl.srcObject = e.streams[0]; };
      dc = pc.createDataChannel("oai-events");

      dc.onopen = () => {
        log("ğŸ“¡ DataChannel æ‰“å¼€");

        // â€”â€” å…³é”®ï¼šiOS å¹³æ»‘ => ä»…æœåŠ¡ç«¯ VADï¼›å…¶å®ƒæ¨¡å¼æ²¿ç”¨åŸé€»è¾‘ â€”â€” //
        const sessionUpdate = { type:"session.update", session: { input_audio_transcription: { model: cfg.sttModel, ...(cfg.langHint ? { language: cfg.langHint } : {}) }, modalities:["text"] } };

        if (cfg.mode === "ios") {
          // ä»…æœåŠ¡ç«¯ VADï¼Œæ‹‰é•¿é™é»˜é˜ˆå€¼ï¼Œé¿å…ç¢ç‰‡
          sessionUpdate.session.turn_detection = {
            type:"server_vad",
            threshold:0.65,
            prefix_padding_ms:320,
            silence_duration_ms:1300,
            create_response:false,
            interrupt_response:true
          };
          log("ğŸŸ© iOS å¹³æ»‘æ¨¡å¼ï¼šä»… server_vadï¼Œå‰ç«¯ä¸å†æœ¬åœ° commit");
        } else if (cfg.mode === "smart") {
          // æœ¬åœ° VADï¼ˆä½ å¯æŒ‰éœ€å†åŠ æœ¬åœ°èƒ½é‡åˆ¤åœï¼‰
          sessionUpdate.session.turn_detection = null;
          log("ğŸŸ¦ æ™ºèƒ½æ¨¡å¼ï¼ˆæœ¬åœ° VADï¼‰");
        } else { // fast
          sessionUpdate.session.turn_detection = null;
          log("ğŸŸ¨ ä½å»¶è¿Ÿæ¨¡å¼ï¼ˆå›ºå®šé—´éš” commitï¼‰");
        }

        dc.send(JSON.stringify(sessionUpdate));
      };

      dc.onmessage = (ev) => { try{ handleRealtimeEvent(JSON.parse(ev.data)); }catch{} };

      // 3) éº¦å…‹é£ï¼ˆiOS: ç¦ç”¨æµè§ˆå™¨å¢ç›Š/é™å™ª/å›å£°ï¼‰
      const micConstr = (cfg.mode === "ios")
        ? { audio: cfg.iosMic }
        : { audio: { channelCount:1, noiseSuppression:true, echoCancellation:true } };
      micStream = await navigator.mediaDevices.getUserMedia(micConstr);
      micTrack = micStream.getAudioTracks()[0]; pc.addTrack(micTrack, micStream);

      // å¯é€‰ï¼šåªåšèƒ½é‡å¯è§†åŒ–ï¼Œä¸å‚ä¸åˆ‡åˆ†ï¼ˆé¿å…â€œäºŒæ¬¡åˆ¤åœâ€ï¼‰
      ac = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:"interactive" });
      const src = ac.createMediaStreamSource(micStream);
      analyser = ac.createAnalyser(); analyser.fftSize = 1024; src.connect(analyser);
      loopMeter(); // ä»…åšèƒ½é‡è¡¨ï¼Œæ— ä»»ä½• commit

      // 4) SDP
      const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
      const rtcResp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(cfg.rtModel)}`, {
        method: "POST",
        headers: { "Authorization": `Bearer ${ephemeralKey}`, "Content-Type":"application/sdp", "OpenAI-Beta":"realtime=v1" },
        body: offer.sdp
      });
      if(!rtcResp.ok){ throw new Error("å»ºç«‹ WebRTC å¤±è´¥: " + await rtcResp.text()); }
      const answer = { type:"answer", sdp: await rtcResp.text() }; await pc.setRemoteDescription(answer);

      // 5) ä½å»¶è¿Ÿæ¨¡å¼æ‰ç”¨å›ºå®š commitï¼›iOS/æ™ºèƒ½æ¨¡å¼å‡ç¦ç”¨æœ¬åœ° commit
      if(cfg.mode === "fast"){
        fixedTimer = setInterval(()=>{ if(!paused) safeCommit(); }, Math.max(300, cfg.commitMs||650));
      }

      paused=false; setStatus("å·²è¿æ¥ Â· æ­£åœ¨è½¬å†™â€¦");
      $("btnToggle").textContent="æš‚åœ"; $("btnToggle").disabled=false;
      $("btnStop").disabled=false; $("btnCopyPreview").disabled=false;
      log("ğŸ§ å°±ç»ªï¼ˆiOS å¹³æ»‘ï¼šä»…æœåŠ¡ç«¯ VAD + é™é»˜å®šæ—¶èšåˆï¼‰");
    }catch(err){
      log("âŒ " + err.message, "danger");
      setStatus("å¤±è´¥"); disableAll(false); cleanup();
    }
  }

  // â€”â€” ä»…åšèƒ½é‡å¯è§†åŒ–ï¼Œç»ä¸è§¦å‘ commit â€”â€” //
  function loopMeter(){
    const buf = new Float32Array(1024);
    let ema = 0, alpha = 0.3;
    const tick = () => {
      if(!analyser) return;
      analyser.getFloatTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; sum+=v*v; }
      const rms = Math.sqrt(sum/buf.length);
      ema = alpha*rms + (1-alpha)*ema;
      rafId = requestAnimationFrame(tick);
    };
    tick();
  }

  // â€”â€” Realtime äº‹ä»¶å¤„ç†ï¼šiOS å¹³æ»‘ç”¨â€œé™é»˜å®šæ—¶è½åœ°â€ï¼Œä¸çœ‹æ ‡ç‚¹ â€”â€” //
  function handleRealtimeEvent(ev){
    const t = ev.type; if(!t) return;
    if(t === "conversation.item.input_audio_transcription.completed"){
      const text = (ev.transcript || "").trim(); if(!text) return;

      // ç´¯åŠ åˆ° live æ–‡æœ¬ï¼ˆåšé‡å åˆå¹¶ï¼‰
      liveSrc = mergeText(liveSrc, text);

      // è¿‘å®æ—¶è¯‘æ–‡ï¼ˆå¯é€‰ï¼‰
      if (cfg.translateOn && cfg.nearRealtime) {
        if (liveTransDebounce) clearTimeout(liveTransDebounce);
        liveTransDebounce = setTimeout(() => doLiveTranslate(liveSrc), 500);
      }

      // â¬… å…³é”®ï¼šåˆ·æ–°é™é»˜å®šæ—¶å™¨ã€‚è‹¥æ— æ–°å­— â‰¥ holdMs æ‰ finalize
      bumpSilenceTimer();

      updatePreview();
    }else if(t === "session.created"){
      log("ğŸŸ¦ session.created");
    }else if(t === "error"){
      log("âš ï¸ Realtime é”™è¯¯: " + (ev.error?.message || JSON.stringify(ev)), "warn");
    }
  }

  function bumpSilenceTimer(){
    if (silenceTimer) clearTimeout(silenceTimer);
    silenceTimer = setTimeout(() => {
      // äºŒæ¬¡ç¡®è®¤ï¼šè‹¥ live å¾ˆçŸ­ï¼ˆ< 15 å­—ï¼‰ä¸”ä¸Šä¸€å¥æœ«å°¾ä¸æ˜¯ç»ˆæ­¢æ ‡ç‚¹ï¼Œå°±å†ç­‰ 600ms
      if (liveSrc && liveSrc.length < 15 && !/[ã€‚ï¼ï¼Ÿ!?â€¦ï¼.]$/.test(liveSrc)) {
        silenceTimer = setTimeout(finalizeLive, 600);
      } else {
        finalizeLive();
      }
    }, cfg.silenceHoldMs);
  }

  // æ–‡æœ¬åˆå¹¶
  function mergeText(prev, cur){
    const cjk = /[\u4E00-\u9FFF\u3040-\u30FF\uAC00-\uD7AF]/;
    const joiner = (cjk.test(prev) || cjk.test(cur)) ? "" : " ";
    if(!prev) return cur;
    const overlap = longestOverlapSuffixPrefix(prev, cur);
    const merged = prev + (overlap>0 ? cur.slice(overlap) : (joiner + cur));
    return merged.replace(/\s+/g," ").trim();
  }
  function longestOverlapSuffixPrefix(a,b){
    const max = Math.min(a.length, b.length, 24);
    for(let k=max;k>3;k--){ if(a.slice(-k).toLowerCase() === b.slice(0,k).toLowerCase()) return k; }
    return 0;
  }

  function finalizeLive(){
    if(!liveSrc) return;

    // è‹¥ä¸ä¸Šä¸€å¥è½åœ°é—´éš”å¾ˆçŸ­ï¼ˆ900msï¼‰ï¼Œè§†ä¸ºåŒå¥ç»­å†™ï¼Œæ‹¼æ¥åˆ°ä¸Šä¸€å¯¹å¹¶è§¦å‘é‡è¯‘
    const now = performance.now();
    if (finalPairs.length > 0 && (finalizeLive.lastTs && (now - finalizeLive.lastTs) < 900)) {
      const prev = finalPairs[finalPairs.length - 1];
      const needSpace = !/[\u4E00-\u9FFF]$/.test(prev.src) && !/^[\u4E00-\u9FFF]/.test(liveSrc);
      prev.src += (needSpace ? " " : "") + liveSrc;
      if (cfg.translateOn) { prev.tgt = null; translateSegment(finalPairs.length - 1).catch(()=>{}); }
    } else {
      finalPairs.push({ src: liveSrc, tgt: cfg.translateOn ? null : "" });
      if (cfg.translateOn) translateSegment(finalPairs.length - 1).catch(()=>{});
    }
    finalizeLive.lastTs = now;

    liveSrc = ""; liveTgt = "";
    updatePreview();
  }

  // â€”â€” ç¿»è¯‘ â€”â€” //
  function pickTargetLanguage(){
    if (cfg.translateTarget !== "auto") return cfg.translateTarget;
    if (cfg.langHint === "zh") return "de";
    if (cfg.langHint === "de" || cfg.langHint === "en") return "zh";
    return "en";
  }

  async function doLiveTranslate(text){
    const reqId = ++liveTransReqId;
    try{
      const tgt = await translateText(text, pickTargetLanguage());
      if (reqId === liveTransReqId) { liveTgt = tgt; updatePreview(); }
    }catch(e){ /* é™é»˜ */ }
  }

  async function translateSegment(index){
    const src = finalPairs[index]?.src || "";
    if (!src) return;
    try{
      const tgt = await translateText(src, pickTargetLanguage());
      finalPairs[index].tgt = tgt;
      updatePreview();
    }catch(e){
      finalPairs[index].tgt = "(ç¿»è¯‘å¤±è´¥ï¼š" + (e.message||"") + ")";
      updatePreview();
      log("âš ï¸ æ®µè½ç¿»è¯‘å¤±è´¥: " + e.message, "warn");
    }
  }

  async function translateText(text, targetLang){
    const resp = await fetch("https://api.openai.com/v1/chat/completions",{
      method:"POST",
      headers:{ "Authorization":`Bearer ${cfg.apiKey}`, "Content-Type":"application/json" },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        temperature: 0.2,
        messages: [
          { role:"system", content:
            `You are a high-quality, low-latency translator.
             Translate the user's text into ${targetLang}.
             Requirements: faithful, fluent, keep punctuation, no comments or quotes.
             If the text seems partial, still translate what's available.`},
          { role:"user", content: text }
        ]
      })
    });
    if(!resp.ok){ const t = await resp.text(); throw new Error("ç¿»è¯‘æ¥å£é”™è¯¯ï¼š" + t); }
    const data = await resp.json();
    const out = data?.choices?.[0]?.message?.content || "";
    return (out||"").trim();
  }

  // â€”â€” æ§åˆ¶ â€”â€” //
  function safeCommit(){ try{ dc && dc.send(JSON.stringify({ type:"input_audio_buffer.commit" })); }catch{} }

  function togglePause(){
    if(!micTrack) return;
    if(!paused){
      micTrack.enabled=false; paused=true; if (cfg.mode !== "ios") safeCommit();
      setStatus("å·²æš‚åœ Â· ä¸å†é‡‡é›†éŸ³é¢‘"); $("btnToggle").textContent="ç»§ç»­"; log("â¸ï¸ å·²æš‚åœéº¦å…‹é£");
    }else{
      micTrack.enabled=true; paused=false;
      setStatus("å·²è¿æ¥ Â· æ­£åœ¨è½¬å†™â€¦"); $("btnToggle").textContent="æš‚åœ"; log("â–¶ï¸ ç»§ç»­é‡‡é›†éº¦å…‹é£");
    }
  }
  function copyPreview(){
    const text = $("preview").value || "";
    navigator.clipboard.writeText(text)
      .then(()=>log("ğŸ“‹ å·²å¤åˆ¶ï¼šé¢„è§ˆæ–‡æœ¬","ok"))
      .catch(e=>log("å¤åˆ¶å¤±è´¥: "+e.message,"warn"));
  }
  function stopAll(){ setStatus("å·²åœæ­¢"); log("â¹ï¸ åœæ­¢"); disableAll(false); cleanup(); }
  function disableAll(working){
    $("btnStart").disabled = working; $("btnToggle").disabled = true;
    $("btnStop").disabled = !working; $("btnCopyPreview").disabled = true;
  }
  function cleanup(){
    if(fixedTimer){ clearInterval(fixedTimer); fixedTimer=null; }
    if(silenceTimer){ clearTimeout(silenceTimer); silenceTimer=null; }
    if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
    try{ dc && dc.close(); }catch{} try{ pc && pc.close(); }catch{}
    try{ micTrack && micTrack.stop(); }catch{}
    try{ micStream && micStream.getTracks().forEach(t=>t.stop()); }catch{}
    if(ac){ try{ ac.close(); }catch{} ac=null; }
    pc=null; dc=null; micTrack=null; micStream=null; analyser=null; ephemeralKey=null; paused=false;
    finalPairs.length=0; liveSrc=""; liveTgt="";
    updatePreview();
  }

  // å·¥å…·
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
})();
</script>
</body>
</html>
