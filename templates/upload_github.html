<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>Markdown 特效转换器 · iPad 选区最终修复 · 单片段单文件/409防冲突</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  :root{
    --bg:#f5f7fb;--card:#fff;--text:#111827;--muted:#6b7280;--line:#e5e7eb;
    --brand-1:#6366f1;--brand-2:#7c3aed;--accent:#22c55e;--danger:#ef4444;--shadow:0 10px 30px rgba(17,24,39,.08);
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.6 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .container{display:flex;gap:16px;padding:16px;height:100vh}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;box-shadow:var(--shadow);padding:16px;overflow:auto}
  .left{width:48%;min-width:320px;display:flex;flex-direction:column;gap:12px}
  .right{flex:1;display:flex;flex-direction:column}
  h2{margin:0 0 8px 0;font-size:18px}
  .subtle{color:var(--muted);font-size:12px}

  .import-card{border:1px dashed var(--line);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:10px;background:linear-gradient(180deg,#fafbff,transparent)}
  .import-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .input-group{display:flex;align-items:center;border:1px solid var(--line);border-radius:10px;overflow:hidden;min-width:280px;background:#fff}
  .input-group input{border:0;padding:10px 12px;outline:none;width:320px;min-width:160px}
  .input-group .btn{border-left:1px solid var(--line);border-radius:0}

  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 14px;border:0;border-radius:10px;cursor:pointer;transition:.2s ease;white-space:nowrap;-webkit-user-select:none;user-select:none}
  .btn svg{width:16px;height:16px}
  .btn-primary{color:#fff;background:linear-gradient(90deg,var(--brand-1),var(--brand-2));box-shadow:0 6px 18px rgba(99,102,241,.25)}
  .btn-primary:hover{transform:translateY(-1px);filter:brightness(1.05)}
  .btn-ghost{background:#f3f4f6;color:#111;border:1px solid var(--line)}
  .btn-ghost:hover{background:#eef2ff;border-color:#c7d2fe}
  .btn:disabled{opacity:.55;cursor:not-allowed;filter:saturate(.6);}

  .pill{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;background:#eef2ff;color:#3730a3;border-radius:999px;font-size:12px}
  .ok-pill{background:#ecfdf5;color:#065f46}

  textarea#markdown-input{width:100%;min-height:260px;resize:vertical;border:1px solid var(--line);border-radius:10px;padding:12px;font:13px/1.6 ui-monospace,SFMono-Regular,Menlo,Monaco,"Courier New",monospace;background:#fcfcff}
  .toolbar{display:flex;gap:8px;align-items:center;margin:8px 0 12px 0;flex-wrap:wrap}
  #html-output{flex:1;border:1px solid var(--line);border-radius:12px;padding:16px;background:#fff;overflow:auto}

  /* iOS 允许文本选择 + 系统菜单（注意 default 才合法） */
  #html-output, #html-output * { -webkit-user-select:text; user-select:text; -webkit-touch-callout:default; }
  #html-output { touch-action: manipulation; }

  @media (pointer:coarse){ .word{ touch-action:manipulation; } }

  span.word{cursor:pointer;transition:background-color .2s}
  span.word:hover{background:#fffbcc}

  .sel-toolbar{
    position:absolute;top:0;left:0;transform:translate(-50%,-120%);
    display:flex;gap:6px;background:#111827;color:#fff;padding:6px 8px;border-radius:10px;
    box-shadow:0 10px 28px rgba(0,0,0,.25);z-index:9999;align-items:center
  }
  .sel-toolbar .btn{padding:6px 10px;border-radius:8px}
  .sel-toolbar .btn-ghost{background:#374151;color:#fff;border-color:#4b5563}
  .hidden{display:none!important}

  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.4);z-index:9998}
  .modal{
    position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);
    width:min(720px,92vw);background:#fff;padding:16px;border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);z-index:9999
  }
  .grid{display:grid;grid-template-columns:160px 1fr;gap:10px 12px;align-items:center}
  .grid input[type="text"], .grid input[type="password"], .grid select{width:100%;padding:10px;border:1px solid var(--line);border-radius:10px}
  .grid .row-span{grid-column:1 / -1}
  .grid .switches{display:flex;flex-wrap:wrap;gap:10px}
  .switch{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--line);border-radius:10px;background:#f9fafb}
  .switch input{transform:scale(1.15)}
  .modal .actions{display:flex;justify-content:flex-end;gap:8px;margin-top:12px}

  .toast{
    position:fixed;left:50%;bottom:26px;transform:translateX(-50%);
    background:#111827;color:#fff;padding:10px 14px;border-radius:10px;box-shadow:0 12px 26px rgba(0,0,0,.25);z-index:10000
  }

  @media (max-width:1000px){.container{flex-direction:column}.left{width:100%}}
</style>
</head>
<body>
<div class="container">
  <!-- LEFT -->
  <section class="panel left" id="left-panel">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <h2>输入 / 导入 Markdown</h2>
      <span id="cfg-state" class="pill" title="GitHub设置状态">未配置</span>
    </div>

    <div class="import-card" id="dropzone">
      <div class="import-row">
        <button id="upload-btn" class="btn btn-primary" type="button" title="选择 .md 文件">
          <svg viewBox="0 0 24 24" fill="none"><path d="M12 16V4m0 0l-4 4m4-4l4 4M6 20h12a2 2 0 0 0 2-2v-3M6 20a2 2 0 0 1-2-2v-3m0 0H3" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round"/></svg>
          上传 .md
        </button>
        <input id="file-input" type="file" accept=".md,.markdown,.txt" class="hidden" />
        <span id="file-name" class="subtle"></span>
        <span class="subtle">也可把文件拖进这块区域</span>
      </div>

      <div class="import-row">
        <div class="input-group" style="flex:1">
          <input id="md-url" type="text" placeholder="粘贴 GitHub/Gist 文件链接（raw 或 /blob/），回车或点右侧导入" />
          <button id="import-url-btn" class="btn btn-ghost" type="button" title="从链接导入">
            <svg viewBox="0 0 24 24" fill="none"><path d="M10 14a5 5 0 0 1 0-7l1.5-1.5a5 5 0 0 1 7 7L17 13M14 10a5 5 0 0 1 0 7L12.5 18.5a5 5 0 0 1-7-7L7 11" stroke="currentColor" stroke-width="1.7" stroke-linecap="round" stroke-linejoin="round"/></svg>
            导入
          </button>
        </div>
        <span class="subtle">私有仓库会使用设置里的 Token 走 API</span>
      </div>
    </div>

    <textarea id="markdown-input" placeholder="在此输入或粘贴 Markdown..."></textarea>
    <span class="subtle">导入后自动在右侧预览；右侧可选中任意内容保存到 GitHub。</span>
  </section>

  <!-- RIGHT -->
  <section class="panel right">
    <h2 style="margin-bottom:6px">Markdown 特效展示</h2>
    <div class="toolbar">
      <button id="convert-btn" class="btn btn-primary" type="button">
        <svg viewBox="0 0 24 24" fill="none"><path d="M12 3l1.5 3.5L17 8l-3.5 1.5L12 13l-1.5-3.5L7 8l3.5-1.5L12 3z" stroke="currentColor" stroke-width="1.4" stroke-linejoin="round"/></svg>
        转换为特效HTML
      </button>
      <button id="toggle-btn" class="btn btn-ghost" type="button">收起输入区</button>
      <button id="download-btn" class="btn btn-ghost" type="button">下载 HTML</button>
      <button id="open-settings-top" class="btn btn-ghost" type="button">设置（GitHub/TTS）</button>

      <button id="save-selection-btn" class="btn btn-primary" type="button" disabled title="先在右侧选中文字">
        <svg viewBox="0 0 24 24" fill="none"><path d="M4 7a2 2 0 0 1 2-2h8l4 4v9a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M8 7h6v5H8z" stroke="currentColor" stroke-width="1.6"/></svg>
        保存选中
      </button>

      <span id="cfg-ok" class="pill ok-pill hidden">GitHub 已配置</span>
    </div>
    <div id="html-output"></div>
  </section>
</div>

<!-- 选区悬浮条 -->
<div id="sel-toolbar" class="sel-toolbar hidden">
  <button id="save-snippet-btn" class="btn btn-primary" type="button">
    <svg viewBox="0 0 24 24" fill="none"><path d="M4 7a2 2 0 0 1 2-2h8l4 4v9a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V7z" stroke="currentColor" stroke-width="1.6"/><path d="M8 7h6v5H8z" stroke="currentColor" stroke-width="1.6"/></svg>
    保存到 GitHub
  </button>
  <button id="open-settings-btn" class="btn btn-ghost" type="button">设置</button>
</div>

<!-- 设置模态框（新增 TTS 区域） -->
<div id="modal-backdrop" class="modal-backdrop hidden"></div>
<div id="settings-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="settings-title">
  <h3 id="settings-title" style="margin:0 0 10px">设置</h3>
  <div class="grid">
    <div class="row-span" style="margin:6px 0 0;font-weight:600">GitHub</div>

    <label for="gh-token">Token*</label>
    <input id="gh-token" type="password" placeholder="Fine-grained token（仅该仓库 contents:write）" />
    <label for="gh-owner">Owner*</label>
    <input id="gh-owner" type="text" placeholder="your-username 或 org-name" />
    <label for="gh-repo">Repo*</label>
    <input id="gh-repo" type="text" placeholder="my-notes" />
    <label for="gh-branch">Branch</label>
    <input id="gh-branch" type="text" placeholder="main（默认）" />
    <label for="gh-dir">目录*</label>
    <input id="gh-dir" type="text" placeholder="snippets/（建议专用目录）" />
    <label for="gh-file">文件名（可留空）</label>
    <input id="gh-file" type="text" placeholder="snippets.md（留空则按日期/小时生成）" />
    <div class="row-span">
      <div class="switches">
        <label class="switch"><input id="gh-per-snippet" type="checkbox" checked> 每条片段单独创建新文件（推荐）</label>
        <label class="switch"><input id="gh-split-hour" type="checkbox"> 追加模式下按小时切分文件名（YYYY-MM-DD-HH.md）</label>
      </div>
    </div>

    <div class="row-span" style="margin:14px 0 0;font-weight:600">TTS 语音</div>
    <label for="tts-mode">模式</label>
    <select id="tts-mode">
      <option value="auto">双轨：远程失败自动回退本地（默认）</option>
      <option value="browser">浏览器优先（最稳）</option>
      <option value="remote">仅远程（FRDic）</option>
    </select>
    <label for="tts-voice">本地语音</label>
    <select id="tts-voice"></select>
    <label for="tts-rate">语速</label>
    <input id="tts-rate" type="text" placeholder="1.1（句子）/ 1.3（单词）" />

    <div class="subtle row-span">参数存于 localStorage（仅本浏览器）。首次点击会做一次静音解锁，确保 iOS 能播放音频。</div>
  </div>
  <div class="actions">
    <button class="btn btn-ghost" id="cancel-settings" type="button">取消</button>
    <button class="btn btn-primary" id="save-settings" type="button">保存</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
/** ================== 基本引用 ================== */
const htmlOutput = document.getElementById('html-output');
const convertBtn = document.getElementById('convert-btn');
const toggleBtn = document.getElementById('toggle-btn');
const downloadBtn = document.getElementById('download-btn');
const leftPanel = document.getElementById('left-panel');
const markdownInput = document.getElementById('markdown-input');

const toolbar = document.getElementById('sel-toolbar');
const saveSelectionBtn = document.getElementById('save-selection-btn');
const saveSnippetBtn   = document.getElementById('save-snippet-btn');

const openSettingsBtn  = document.getElementById('open-settings-btn');
const openSettingsTop  = document.getElementById('open-settings-top');
const modal    = document.getElementById('settings-modal');
const backdrop = document.getElementById('modal-backdrop');

const elToken  = document.getElementById('gh-token');
const elOwner  = document.getElementById('gh-owner');
const elRepo   = document.getElementById('gh-repo');
const elBranch = document.getElementById('gh-branch');
const elDir    = document.getElementById('gh-dir');
const elFile   = document.getElementById('gh-file');
const elPerSnippet = document.getElementById('gh-per-snippet');
const elSplitHour  = document.getElementById('gh-split-hour');

const cfgState = document.getElementById('cfg-state');
const cfgOk    = document.getElementById('cfg-ok');

const elTtsMode  = document.getElementById('tts-mode');
const elTtsVoice = document.getElementById('tts-voice');
const elTtsRate  = document.getElementById('tts-rate');

/** 其它引用（上传/导入） */
const uploadBtn   = document.getElementById('upload-btn');
const fileInput   = document.getElementById('file-input');
const fileNameSpan= document.getElementById('file-name');
const urlInput    = document.getElementById('md-url');
const importUrlBtn= document.getElementById('import-url-btn');
const dropzone    = document.getElementById('dropzone');

/** 导入来源（用于 Source 字段） */
let sourceOverride = null;

/** 选区快照（iPad：按钮点击不丢选区） */
let latestSelection = { text:'', range:null };
const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);

/** ================== Markdown → HTML ================== */
convertBtn.addEventListener('click', () => {
  const md = markdownInput.value || '';
  const rawHtml = marked.parse(md);
  htmlOutput.innerHTML = rawHtml;
  wrapWords(htmlOutput);
  latestSelection = { text:'', range:null };
  handleSelectionChange();
});
toggleBtn.addEventListener('click', () => {
  leftPanel.style.display = leftPanel.style.display === 'none' ? '' : 'none';
  toggleBtn.textContent = (leftPanel.style.display === 'none') ? '显示输入区' : '收起输入区';
});
downloadBtn.addEventListener('click', () => {
  const content = htmlOutput.innerHTML;
  const tpl = `<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>导出HTML</title>
  <style>body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;padding:20px;background:#f8fafc}span.word{cursor:pointer}span.word:hover{background:#fffbcc}</style>
  </head><body>${content}</body></html>`;
  const blob = new Blob([tpl],{type:'text/html'});
  const url = URL.createObjectURL(blob);
  const a = Object.assign(document.createElement('a'),{href:url,download:'markdown_export.html'});
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
});

/** ================== 包裹词（仅包裹，无监听；监听在容器上事件委托） ================== */
function wrapWords(root){
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
  const nodes = [];
  while (walker.nextNode()) nodes.push(walker.currentNode);
  nodes.forEach(node => {
    const parent = node.parentNode;
    const text = node.textContent;
    const frags = text.split(/([a-zA-Z0-9äöüÄÖÜß]+)/);
    const fragRoot = document.createDocumentFragment();
    const sentence = text.trim();
    frags.forEach(part=>{
      if (/^[a-zA-Z0-9äöüÄÖÜß]+$/.test(part)) {
        const span = document.createElement('span');
        span.className='word'; span.textContent = part;
        span.setAttribute('data-word', part);
        span.setAttribute('data-sentence', sentence);
        fragRoot.appendChild(span);
      } else {
        fragRoot.appendChild(document.createTextNode(part));
      }
    });
    parent.replaceChild(fragRoot, node);
  });
}

/** ================== iOS 选区守望者 ================== */
let selWatchTimer = null;
function startSelectionWatcher(windowMs=1500, intervalMs=120){
  stopSelectionWatcher();
  const t0 = Date.now();
  selWatchTimer = setInterval(()=>{
    const sel = window.getSelection();
    if(sel && sel.rangeCount>0 && !sel.isCollapsed && selectionInsideOutput(sel)){
      latestSelection = { text: sel.toString().trim(), range: sel.getRangeAt(0).cloneRange() };
      updateSaveButtons();
      stopSelectionWatcher();
    }
    if(Date.now() - t0 > windowMs) stopSelectionWatcher();
  }, intervalMs);
}
function stopSelectionWatcher(){
  if(selWatchTimer){ clearInterval(selWatchTimer); selWatchTimer=null; }
}

function selectionInsideOutput(sel){
  if(!sel || sel.rangeCount===0 || sel.isCollapsed) return false;
  const rng = sel.getRangeAt(0);
  const nodeOf = n => n?.nodeType===1 ? n : n?.parentNode;
  const container = nodeOf(rng.commonAncestorContainer);
  const start = nodeOf(rng.startContainer);
  const end   = nodeOf(rng.endContainer);
  if (container && htmlOutput.contains(container)) return true;
  if ((start && htmlOutput.contains(start)) || (end && htmlOutput.contains(end))) return true;
  try{
    const rect = rng.getBoundingClientRect?.();
    const o = htmlOutput.getBoundingClientRect?.();
    if(rect && o){
      const overlap = !(rect.right<o.left || rect.left>o.right || rect.bottom<o.top || rect.top>o.bottom);
      if (overlap) return true;
    }
  }catch{}
  return false;
}

function snapshotSelectionNow(){
  const sel = window.getSelection();
  if(sel && sel.rangeCount>0 && !sel.isCollapsed && selectionInsideOutput(sel)){
    latestSelection = { text: sel.toString().trim(), range: sel.getRangeAt(0).cloneRange() };
    updateSaveButtons();
  }
}

/** ======== 改进：仅当“当前确有选区文本”才拦截点读；否则清空旧快照 ======== */
function hasActiveSelectionInsideOutput(){
  const sel = window.getSelection?.();
  const t = (sel && sel.toString && sel.toString().trim()) || '';
  return !!(t.length>0 && sel.rangeCount>0 && selectionInsideOutput(sel));
}
document.addEventListener('selectionchange', () => {
  if (hasActiveSelectionInsideOutput()) {
    startSelectionWatcher(1200, 120);
  } else if (latestSelection.text) {
    latestSelection = { text:'', range:null };
    updateSaveButtons();
  }
});
htmlOutput.addEventListener('contextmenu', ()=>{ startSelectionWatcher(1200, 120); }, true);
['touchstart','touchmove','touchend'].forEach(ev=>{
  htmlOutput.addEventListener(ev, ()=>{ startSelectionWatcher(1500, 120); }, {passive:true});
});
htmlOutput.addEventListener('pointerdown', () => {
  if (!hasActiveSelectionInsideOutput() && latestSelection.text){
    latestSelection = { text:'', range:null };
    updateSaveButtons();
  }
},{passive:true});

/** ================== 事件委托：点击=读词；长按=读句 ================== */
let longPressTimer=null, pressTarget=null;
htmlOutput.addEventListener('click', (e) => {
  const span = e.target.closest?.('span.word');
  if (!span) return;
  if (hasActiveSelectionInsideOutput()) return;
  const w = span.getAttribute('data-word');
  if (w) speakWord(w);
});
htmlOutput.addEventListener('pointerdown', (e)=>{
  const span = e.target.closest?.('span.word');
  if (!span) return;
  if (hasActiveSelectionInsideOutput()) return;
  pressTarget = span;
  longPressTimer = setTimeout(()=>{
    const s = span.getAttribute('data-sentence') || span.textContent || '';
    if (s.trim()) speakSentence(s.trim());
    longPressTimer = null; pressTarget = null;
  }, 380); // 触屏长按阈值
},{passive:true});
['pointerup','pointercancel','pointerleave'].forEach(ev=>{
  htmlOutput.addEventListener(ev, ()=>{
    if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=null; pressTarget=null; }
  }, {passive:true});
});

/** ================== 悬浮条 UI & 按钮状态 ================== */
function updateSaveButtons(){
  const has = !!(latestSelection.text && latestSelection.text.length>0);
  saveSelectionBtn.disabled = !has || _savingFlag;
  saveSnippetBtn.disabled   = !has || _savingFlag;
  saveSelectionBtn.innerText = has ? `保存选中（${latestSelection.text.length}字）` : '保存选中';
  if (has && latestSelection.range){
    try{
      const r = latestSelection.range.getBoundingClientRect();
      const top  = r.top + window.scrollY;
      const left = r.left + r.width/2 + window.scrollX;
      toolbar.style.top = `${top}px`;
      toolbar.style.left = `${left}px`;
      show(toolbar);
    }catch{ hide(toolbar); }
  }else{
    hide(toolbar);
  }
}
document.addEventListener('scroll', ()=>hide(toolbar), true);
window.addEventListener('resize', ()=>hide(toolbar));

/** ================== 保存按钮绑定（iPad 关键：touchstart） ================== */
function bindSaveButton(btn){
  btn.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    doSaveCurrentSelection();
  }, {passive:false});
  btn.addEventListener('click', (e)=>{
    if (isTouch) return;
    doSaveCurrentSelection();
  });
  btn.addEventListener('mousedown', (e)=>{ e.preventDefault(); }, {passive:false});
}
bindSaveButton(saveSelectionBtn);
bindSaveButton(saveSnippetBtn);

/** ================== 保存主流程 ================== */
const MIN_INTERVAL_MS = 400;
let _savingFlag = false;
let _lastSaveTs = 0;

async function doSaveCurrentSelection(){
  const nowTs = Date.now();
  if (nowTs - _lastSaveTs < MIN_INTERVAL_MS) { toast('操作过快，稍等一下…'); return; }
  const cfg = getConfig();
  if(!cfg.token || !cfg.owner || !cfg.repo || !cfg.dir){ openSettings(); return; }

  if(!latestSelection.text) snapshotSelectionNow();
  const text = latestSelection.text || '';
  if(!text){ toast('请先在右侧预览文本中选择！'); return; }

  if(_savingFlag) return;
  _savingFlag = true;
  updateSaveButtons();

  try{
    const now = new Date();
    const timeStr = new Intl.DateTimeFormat('zh-CN',{
      timeZone:'Europe/Berlin', year:'numeric', month:'2-digit', day:'2-digit',
      hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false
    }).format(now).replace(/\//g,'-');

    const sourceTitle = (sourceOverride?.title) ? sourceOverride.title : (document.title || 'Untitled Page');
    const sourceUrl   = (sourceOverride?.url)   ? sourceOverride.url   : location.href;

    const entry = `

---
**Time:** ${timeStr} (Europe/Berlin)  
**Source:** [${escapeMd(sourceTitle)}](${sourceUrl})

> ${escapeMd(text).replace(/\n/g,'\n> ')}
`;

    const tz = 'Europe/Berlin';
    const yyyy = new Intl.DateTimeFormat('en-CA',{timeZone:tz, year:'numeric'}).format(now);
    const mm   = new Intl.DateTimeFormat('en-CA',{timeZone:tz, month:'2-digit'}).format(now);
    const dd   = new Intl.DateTimeFormat('en-CA',{timeZone:tz, day:'2-digit'}).format(now);
    const HH   = String(now.getHours()).padStart(2,'0');

    if (getConfig().perSnippet){
      await saveAsNewFile(getConfig(), entry, `save snippet @ ${timeStr}`, {yyyy,mm,dd,HH});
    } else {
      const fileName = (getConfig().file && getConfig().file.trim())
        ? getConfig().file.trim()
        : (getConfig().splitHour ? `${yyyy}-${mm}-${dd}-${HH}.md` : `${yyyy}-${mm}-${dd}.md`);
      const path = getConfig().dir + fileName;
      await withWriteLock(path, async () => {
        await safeAppendToFile(getConfig(), path, entry, `append snippet @ ${timeStr}`);
      });
    }

    _lastSaveTs = Date.now();
    toast('已保存到 GitHub ✅');
  }catch(err){
    const extra = err?.detail ? `\n${String(err.detail).slice(0,180)}` : '';
    toast('保存失败：'+(err?.message||'未知错误')+extra);
  }finally{
    _savingFlag = false;
    updateSaveButtons();
  }
}

/** ================== 文件/链接导入 ================== */
uploadBtn.addEventListener('click',()=>fileInput.click());
fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0]; if(!file) return;
  if (file.size > 10*1024*1024){ toast('文件过大（>10MB）'); return;}
  try{
    const txt = await file.text();
    fileNameSpan.textContent = file.name;
    sourceOverride = {title:`Local file: ${file.name}`, url:`file://${file.name}`};
    loadMarkdownIntoEditor(txt);
    toast('已导入本地文件 ✅');
  }catch{ toast('读取文件失败'); }
});
['dragenter','dragover'].forEach(evt=>{
  dropzone.addEventListener(evt, e=>{
    e.preventDefault();
    dropzone.style.borderColor = 'var(--brand-1)';
    dropzone.style.boxShadow = '0 0 0 3px rgba(99,102,241,.15)';
  });
});
['dragleave','drop'].forEach(evt=>{
  dropzone.addEventListener(evt, e=>{
    e.preventDefault();
    dropzone.style.borderColor = 'var(--line)';
    dropzone.style.boxShadow = 'none';
  });
});
dropzone.addEventListener('drop', async (e)=>{
  const file = e.dataTransfer?.files?.[0]; if(!file) return;
  if (!/\.(md|markdown|txt)$/i.test(file.name)){ toast('请拖入 .md/.markdown/.txt 文件'); return;}
  if (file.size > 10*1024*1024){ toast('文件过大（>10MB）'); return;}
  try{
    const txt = await file.text();
    fileNameSpan.textContent = file.name;
    sourceOverride = {title:`Local file: ${file.name}`, url:`file://${file.name}`};
    loadMarkdownIntoEditor(txt);
    toast('已导入本地文件 ✅');
  }catch{ toast('读取文件失败'); }
});

importUrlBtn.addEventListener('click', importFromUrl);
urlInput.addEventListener('keydown', e=>{ if(e.key==='Enter') importFromUrl(); });
async function importFromUrl(){
  const u = urlInput.value.trim();
  if(!u){ toast('请粘贴 GitHub/Gist 文件链接'); return;}
  toast('正在导入...');
  try{
    const text = await fetchMarkdownFromUrl(u, getConfig().token);
    sourceOverride = {title:'Imported from URL', url:u};
    loadMarkdownIntoEditor(text);
    toast('已从链接导入 ✅');
  }catch(err){
    toast('导入失败：'+(err?.message||'未知错误'));
  }
}
function loadMarkdownIntoEditor(text){
  markdownInput.value = text;
  convertBtn.click();
  htmlOutput.scrollTop = 0;
}
async function fetchMarkdownFromUrl(url, token){
  let u; try{ u = new URL(url); }catch{ throw new Error('无效链接'); }
  const host = u.host.toLowerCase();
  if(host==='raw.githubusercontent.com' || host==='gist.githubusercontent.com'){
    const r = await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(`获取失败(${r.status})`);
    return await r.text();
  }
  if(host==='github.com'){
    const parts = u.pathname.split('/').filter(Boolean);
    const blobIdx = parts.indexOf('blob');
    if (blobIdx!==-1 && parts.length>blobIdx+2){
      const owner = parts[0], repo = parts[1], branch = parts[blobIdx+1];
      const path  = parts.slice(blobIdx+2).join('/');
      const raw = `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
      const r1 = await fetch(raw,{cache:'no-store'}); if (r1.ok) return await r1.text();
      const api = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
      const r2 = await fetch(api,{headers:{'Accept':'application/vnd.github+json', ...(token?{'Authorization':`Bearer ${token}`}:{}) ,'X-GitHub-Api-Version':'2022-11-28'}});
      if(!r2.ok) throw new Error(`API 获取失败(${r2.status})`);
      const json = await r2.json();
      return b64Decode(json.content||'');
    }
    throw new Error('请使用 raw 链接或包含 /blob/ 的文件页链接');
  }
  if(host==='gist.github.com'){
    const parts = u.pathname.split('/').filter(Boolean);
    if(parts.length<2) throw new Error('无效 Gist 链接');
    const gistId = parts[1];
    const r = await fetch(`https://api.github.com/gists/${gistId}`,{headers:{'Accept':'application/vnd.github+json', ...(token?{'Authorization':`Bearer ${token}`}:{})}});
    if(!r.ok) throw new Error(`Gist 获取失败(${r.status})`);
    const json = await r.json();
    const files = json.files||{};
    const first = Object.keys(files).find(k => typeof files[k]?.content === 'string');
    if(!first) throw new Error('Gist 中未发现文本文件');
    return files[first].content;
  }
  const r = await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(`获取失败(${r.status})`);
  return await r.text();
}

/** ================== 并发串行 & 409 退避 ================== */
const writeQueues = new Map();
function withWriteLock(path, task){
  const prev = writeQueues.get(path) || Promise.resolve();
  const next = prev.then(task).finally(()=>{
    if(writeQueues.get(path) === next) writeQueues.delete(path);
  });
  writeQueues.set(path, next);
  return next;
}
const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

async function saveAsNewFile(cfg, entry, commitMsg, parts){
  const {yyyy,mm,dd,HH} = parts;
  const d2 = (n)=>String(n).padStart(2,'0');
  const now = new Date();
  const mi = d2(now.getMinutes()), ss=d2(now.getSeconds());
  const ms = String(now.getMilliseconds()).padStart(3,'0');
  const rand = (self.crypto?.getRandomValues
    ? (()=>{ const u32 = new Uint32Array(1); self.crypto.getRandomValues(u32); return u32[0].toString(36).slice(0,6); })()
    : Math.random().toString(36).slice(2,8));
  const fileName = `snip-${yyyy}${mm}${dd}-${HH}${mi}${ss}-${ms}-${rand}.md`;
  const path = `${cfg.dir}${yyyy}/${mm}/${dd}/${fileName}`.replace(/\/+/g,'/');
  await githubPutFile(cfg, path, entry, undefined, commitMsg);
}
async function safeAppendToFile(cfg, path, appendedContent, commitMsg){
  const MAX_RETRY = 5;
  for(let attempt=1; attempt<=MAX_RETRY; attempt++){
    const existing = await githubGetFile(cfg, path);
    const header = '# Collected Snippets\n';
    const base = existing?.contentStr ?? header;
    const newContent = (base.endsWith('\n') ? base : base + '\n') + appendedContent;
    try{
      await githubPutFile(cfg, path, newContent, existing?.sha, commitMsg);
      return;
    }catch(e){
      if(e.status === 409){ await sleep(150 * attempt + Math.random()*300); continue; }
      if((e.status===403 || e.status===429) && e.retryAfterMs){ await sleep(e.retryAfterMs + Math.random()*300); continue; }
      throw e;
    }
  }
  throw new Error('多次重试后仍 409：并发写入过多或分支受保护。可切换“每条片段单独新文件”或改用不受保护的分支。');
}

/** ================== 设置存取 ================== */
const btnCancel = document.getElementById('cancel-settings');
const btnSave   = document.getElementById('save-settings');
[openSettingsBtn, openSettingsTop].forEach(b=>b.addEventListener('click', openSettings));
btnCancel.addEventListener('click', closeSettings);
backdrop.addEventListener('click', closeSettings);
btnSave.addEventListener('click', ()=>{
  saveSettings();
  updateCfgBadge();
  closeSettings();
  toast('设置已保存');
});

function getConfig(){
  const dirRaw = (localStorage.getItem('gh_dir') || elDir.value.trim() || 'snippets/');
  return {
    token:  localStorage.getItem('gh_token')  || elToken.value.trim(),
    owner:  localStorage.getItem('gh_owner')  || elOwner.value.trim(),
    repo:   localStorage.getItem('gh_repo')   || elRepo.value.trim(),
    branch: localStorage.getItem('gh_branch') || elBranch.value.trim() || 'main',
    dir:    dirRaw.replace(/^\/+/, '').replace(/\/?$/, '/') || 'snippets/',
    file:   localStorage.getItem('gh_file')   || elFile.value.trim(),
    perSnippet: (localStorage.getItem('gh_per_snippet') ?? (elPerSnippet.checked ? '1':'')).toString() === '1',
    splitHour:  (localStorage.getItem('gh_split_hour')  ?? (elSplitHour.checked  ? '1':'')).toString() === '1',

    // TTS
    ttsMode: localStorage.getItem('tts_mode') || elTtsMode.value || 'auto',
    ttsVoice: localStorage.getItem('tts_voice') || elTtsVoice.value || '',
    ttsRate: parseFloat(localStorage.getItem('tts_rate') || elTtsRate.value || '0') || 0
  };
}
function saveSettings(){
  localStorage.setItem('gh_token',  elToken.value.trim());
  localStorage.setItem('gh_owner',  elOwner.value.trim());
  localStorage.setItem('gh_repo',   elRepo.value.trim());
  localStorage.setItem('gh_branch', elBranch.value.trim() || 'main');
  localStorage.setItem('gh_dir',    elDir.value.trim());
  localStorage.setItem('gh_file',   elFile.value.trim());
  localStorage.setItem('gh_per_snippet', elPerSnippet.checked ? '1':'0');
  localStorage.setItem('gh_split_hour',  elSplitHour.checked  ? '1':'0');

  localStorage.setItem('tts_mode',  elTtsMode.value);
  localStorage.setItem('tts_voice', elTtsVoice.value);
  localStorage.setItem('tts_rate',  elTtsRate.value.trim());
}
function loadSettings(){
  elToken.value  = localStorage.getItem('gh_token')  || '';
  elOwner.value  = localStorage.getItem('gh_owner')  || '';
  elRepo.value   = localStorage.getItem('gh_repo')   || '';
  elBranch.value = localStorage.getItem('gh_branch') || 'main';
  elDir.value    = localStorage.getItem('gh_dir')    || 'snippets/';
  elFile.value   = localStorage.getItem('gh_file')   || '';
  const per = localStorage.getItem('gh_per_snippet');
  const hr  = localStorage.getItem('gh_split_hour');
  elPerSnippet.checked = per === null ? true : per === '1';
  elSplitHour.checked  = hr  === null ? false: hr  === '1';

  elTtsMode.value  = localStorage.getItem('tts_mode') || 'auto';
  elTtsRate.value  = localStorage.getItem('tts_rate') || ''; // 空表示用默认 1.1/1.3

  // 语音列表
  refreshVoices();
  const savedVoice = localStorage.getItem('tts_voice') || '';
  if (savedVoice) elTtsVoice.value = savedVoice;
}
function updateCfgBadge(){
  const cfg = getConfig();
  const ok = !!(cfg.token && cfg.owner && cfg.repo && cfg.dir);
  cfgState.textContent = ok ? '已配置' : '未配置';
  cfgState.className = 'pill ' + (ok?'ok-pill':'');

  if (cfgOk?.classList?.toggle) cfgOk.classList.toggle('hidden', !ok);
}
function openSettings(){ show(backdrop); show(modal); }
function closeSettings(){ hide(modal); hide(backdrop); }

/** ================== GitHub API ================== */
const GH_API = 'https://api.github.com';
async function githubGetFile(cfg, path){
  const url = `${GH_API}/repos/${encodeURIComponent(cfg.owner)}/${encodeURIComponent(cfg.repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(cfg.branch)}`;
  const res = await fetch(url,{headers:{
    'Accept':'application/vnd.github+json',
    'Authorization':`Bearer ${cfg.token}`,
    'X-GitHub-Api-Version':'2022-11-28'
  }});
  if(res.status===404) return null;
  if(!res.ok){
    const txt=await res.text();
    const err = new Error(`读取文件失败 (${res.status})`);
    err.status = res.status;
    err.detail = txt;
    addRateLimitMeta(err, res);
    throw err;
  }
  const json = await res.json();
  const contentStr = b64Decode(json.content||'');
  return { sha: json.sha, contentStr };
}
async function githubPutFile(cfg, path, contentStr, sha, message){
  const url = `${GH_API}/repos/${encodeURIComponent(cfg.owner)}/${encodeURIComponent(cfg.repo)}/contents/${encodeURIComponent(path)}`;
  const body = { message: message || 'update file', content: b64Encode(contentStr), branch: cfg.branch };
  if (sha) body.sha = sha;
  const res = await fetch(url,{
    method:'PUT',
    headers:{
      'Accept':'application/vnd.github+json',
      'Authorization':`Bearer ${cfg.token}`,
      'X-GitHub-Api-Version':'2022-11-28',
      'Content-Type':'application/json'
    },
    body:JSON.stringify(body)
  });
  if(!res.ok){
    const txt = await res.text();
    const err = new Error(
      res.status===401 ? '401 未授权：Token无效或权限不足' :
      res.status===403 ? '403 被拒绝：分支保护/权限/速率限制' :
      res.status===404 ? '404 未找到：仓库/分支/路径可能错误' :
      res.status===409 ? '409 冲突：分支/sha 冲突（并发写入/sha过期）' :
      `保存失败 (${res.status})`
    );
    err.status = res.status;
    err.detail = txt;
    addRateLimitMeta(err, res);
    throw err;
  }
  return res.json();
}
function addRateLimitMeta(err, res){
  const ra = res.headers.get('retry-after');
  if(ra){
    const ms = /^\d+$/.test(ra) ? parseInt(ra,10)*1000 : 0;
    if(ms>0) err.retryAfterMs = ms;
  }
  const rlRem = res.headers.get('x-ratelimit-remaining');
  const rlReset = res.headers.get('x-ratelimit-reset');
  if(rlRem!==null) err.rateRemaining = rlRem;
  if(rlReset!==null) err.rateReset = rlReset;
}

/** ================== TTS：可靠播放管线 ================== */

// —— 1) 用户手势静音解锁（iOS/Safari 对 <audio>.play 的策略需要一次真实手势）
let mediaUnlocked = false;
const silentDataUri = "data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQAA";
function unlockMediaOnce(){
  if (mediaUnlocked) return;
  const a = new Audio(silentDataUri);
  a.play().catch(()=>{}).finally(()=>{ mediaUnlocked = true; });
}
document.addEventListener('click', unlockMediaOnce, {once:true, capture:true});
document.addEventListener('touchend', unlockMediaOnce, {once:true, capture:true});

// —— 2) 单例播放器 + 超时兜底
const tts = { audio: new Audio(), lastTs: 0, minGap: 160 };
tts.audio.preload = 'none';

function getRates(){
  const cfg = getConfig();
  const base = (cfg.ttsRate && cfg.ttsRate>0) ? cfg.ttsRate : 0;
  return {
    word: base || 1.3,
    sent: base ? Math.max(0.8, base-0.2) : 1.1
  };
}

function speakRemote(url, plain, rate, timeoutMs=1800){
  return new Promise((resolve,reject)=>{
    try { tts.audio.pause(); } catch {}
    tts.audio.playbackRate = rate;
    const cacheBust = (url.includes('?') ? '&' : '?') + '_=' + Date.now();
    tts.audio.src = url + cacheBust;
    tts.audio.currentTime = 0;

    let done=false;
    const onPlay = ()=>{ if(done) return; done=true; cleanup(); resolve(); };
    const onErr  = (e)=>{ if(done) return; done=true; cleanup(); reject(e||new Error('audio error')); };
    const onStall= ()=>{ /* 网络抖动，等超时 */ };

    tts.audio.addEventListener('playing', onPlay, {once:true});
    tts.audio.addEventListener('play', onPlay, {once:true});
    tts.audio.addEventListener('error', onErr, {once:true});
    tts.audio.addEventListener('stalled', onStall);
    tts.audio.addEventListener('suspend', onStall);
    const to = setTimeout(()=>{ onErr(new Error('remote tts timeout')); }, timeoutMs);

    function cleanup(){
      clearTimeout(to);
      tts.audio.removeEventListener('playing', onPlay);
      tts.audio.removeEventListener('play', onPlay);
      tts.audio.removeEventListener('error', onErr);
      tts.audio.removeEventListener('stalled', onStall);
      tts.audio.removeEventListener('suspend', onStall);
    }

    tts.audio.play().catch(onErr);
  });
}

function speakLocal(text, rate){
  if (!('speechSynthesis' in window)) throw new Error('no speechSynthesis');
  try { window.speechSynthesis.cancel(); } catch {}
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'de-DE';
  u.rate = rate;
  const voiceName = getConfig().ttsVoice || '';
  if (voiceName){
    const vs = window.speechSynthesis.getVoices();
    const v = vs.find(x => (x.name===voiceName) || (voiceName && x.name?.toLowerCase().includes(voiceName.toLowerCase())));
    if (v) u.voice = v;
  }
  window.speechSynthesis.speak(u);
}

/** 统一入口：根据模式选择远程/本地/双轨 */
function speak(text, kind){ // kind: 'word' | 'sent'
  const now = Date.now();
  if (now - tts.lastTs < tts.minGap) return;
  tts.lastTs = now;

  const rates = getRates();
  const rate = (kind==='word') ? rates.word : rates.sent;
  const mode = getConfig().ttsMode || 'auto';

  const remoteUrl = "https://api.frdic.com/api/v2/speech/speakweb?langid=de&txt=" + encodeURIComponent(text);
  if (mode === 'browser'){
    try { speakLocal(text, rate); } catch { toast('本地 TTS 不可用'); }
    return;
  }
  if (mode === 'remote'){
    speakRemote(remoteUrl, text, rate).catch(()=>{
      toast('远程语音被阻止/超时');
    });
    return;
  }
  // auto 双轨
  speakRemote(remoteUrl, text, rate).catch(()=>{
    try { speakLocal(text, rate); } catch { toast('语音失败（远程+本地）'); }
  });
}
function speakWord(w){ speak(w, 'word'); }
function speakSentence(s){ speak(s, 'sent'); }

/** 语音列表加载 */
function refreshVoices(){
  if (!('speechSynthesis' in window)) { elTtsVoice.innerHTML = '<option value="">（当前浏览器不支持）</option>'; return; }
  const fill = ()=>{
    const vs = window.speechSynthesis.getVoices();
    const opts = ['<option value="">自动</option>'].concat(
      vs.map(v => `<option value="${escapeHtml(v.name)}">${escapeHtml(v.name)} ${v.lang?'('+v.lang+')':''}</option>`)
    );
    elTtsVoice.innerHTML = opts.join('');
  };
  fill();
  window.speechSynthesis.onvoiceschanged = fill;
}
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }

/** ================== 工具 & 初始化 ================== */
function show(el){ el.classList.remove('hidden'); }
function hide(el){ el.classList.add('hidden'); }
function toast(msg, ms=2200){ const t=document.createElement('div'); t.className='toast'; t.textContent=msg; document.body.appendChild(t); setTimeout(()=>t.remove(), ms); }
function b64Encode(str){ const bytes=new TextEncoder().encode(str); let bin=''; bytes.forEach(b=>bin+=String.fromCharCode(b)); return btoa(bin); }
function b64Decode(b64){ const bin=atob((b64||'').replace(/\n/g,'')); const len=bin.length; const bytes=new Uint8Array(len); for(let i=0;i<len;i++) bytes[i]=bin.charCodeAt(i); return new TextDecoder().decode(bytes); }
function escapeMd(str){ return str.replace(/[*_`~]/g, m=>'\\'+m); }
function handleSelectionChange(){ updateSaveButtons(); }

window.onload = ()=>{
  htmlOutput.innerHTML = '<p class="subtle">左侧可 <b>上传/拖拽 .md</b> 或 <b>GitHub/Gist 链接导入</b>；右侧<b>点击</b>读词，<b>长按</b>读整句；长按选择后点「保存选中」。<br>本版已含：iOS 手势解锁、双轨 TTS 回退、底部段落同样灵敏。</p>';
  loadSettings();
  updateCfgBadge();
};
</script>
</body>
</html>
