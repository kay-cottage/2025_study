<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>实时语音转写 + 实时翻译 · 单预览框（iOS优化）</title>
<style>
  :root{--bg:#0b1020;--panel:#111936;--text:#e7ecff;--muted:#93a4c3;--line:#1f2a4d;
    --brand:#7c9dfc;--ok:#22c55e;--warn:#f59e0b;--danger:#ef4444;--shadow:0 20px 50px rgba(3,8,23,.4)}
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b1020,#0f1530 60%,#0b1020);color:var(--text);
       font:15px/1.6 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
  .card{background:linear-gradient(180deg,#0f1633,#0e1630);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)}
  .header{padding:16px 20px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center;justify-content:space-between}
  .title{font-size:18px;font-weight:700;letter-spacing:.2px}
  .pill{border:1px solid var(--line);color:var(--muted);padding:4px 8px;border-radius:999px;font-size:12px}
  .body{padding:16px 20px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:12px 0}
  .row > *{flex:1}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input,select,button,textarea{background:#0b122b;border:1px solid var(--line);color:var(--text);
    border-radius:10px;padding:10px 12px;outline:none}
  input::placeholder{color:#6b7280}
  select{cursor:pointer}
  button{cursor:pointer;transition:.15s ease;border:1px solid #2a3870}
  button.primary{background:linear-gradient(180deg,#4f6df7,#4a61e6);border:none}
  button.ghost{background:#0b122b}
  button:disabled{opacity:.6;cursor:not-allowed}
  .btns{display:flex;gap:10px;flex-wrap:wrap}
  .status{font-size:13px;color:var(--muted)}
  .log{background:#0b122b;border:1px dashed #213069;border-radius:12px;padding:12px;height:140px;overflow:auto}
  .preview-wrap{position:relative;margin-top:6px}
  #preview{width:100%;height:560px;resize:vertical}
  .copy-fab{position:absolute;right:8px;top:8px;background:#101a3b;border:1px solid #2a3870;border-radius:8px;padding:6px 10px;font-size:12px}
  details.settings{margin:14px 0;border:1px solid var(--line);border-radius:12px;overflow:hidden}
  details.settings[open]{box-shadow:var(--shadow)}
  details.settings summary{list-style:none;cursor:pointer;background:#0d1534;padding:12px 14px;display:flex;align-items:center;gap:10px;
    user-select:none;border-bottom:1px solid var(--line)}
  details.settings summary::-webkit-details-marker{display:none}
  .chev{width:10px;height:10px;border-right:2px solid #7c9dfc;border-bottom:2px solid #7c9dfc;transform:rotate(-45deg);transition:.2s}
  details.settings[open] .chev{transform:rotate(45deg)}
  .controls{padding:14px;display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  @media (max-width:1000px){.controls{grid-template-columns:1fr}}
  .small{font-size:12px} .muted{color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="header">
      <div class="title">实时语音转写 <span class="pill">智能分句 · 实时翻译</span></div>
      <div class="status" id="status">未连接</div>
    </div>

    <div class="body">
      <!-- 顶部核心输入 -->
      <div class="row">
        <div>
          <label>OpenAI API Key（本地调试用；线上改为后端签发临时密钥）</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
        </div>
        <div>
          <label>Realtime 会话模型</label>
          <select id="rtModel">
            <option value="gpt-4o-mini-realtime-preview-2024-12-17" selected>gpt-4o-mini-realtime</option>
            <option value="gpt-4o-realtime-preview-2024-12-17">gpt-4o-realtime</option>
          </select>
        </div>
        <div>
          <label>转写模型</label>
          <select id="sttModel">
            <option value="gpt-4o-mini-transcribe" selected>gpt-4o-mini-transcribe</option>
            <option value="gpt-4o-transcribe">gpt-4o-transcribe</option>
          </select>
        </div>
      </div>

      <!-- 可折叠参数（默认收起） -->
      <details class="settings">
        <summary><span class="chev"></span><b>参数设置（可收起/展开）</b><span class="muted small"> · 断句/延迟/翻译</span></summary>
        <div class="controls">
          <div>
            <label>分句模式</label>
            <select id="mode">
              <option value="smart" selected>智能分句（默认）</option>
              <option value="fast">低延迟（固定间隔微分段）</option>
            </select>
          </div>
          <div>
            <label>转写语言提示</label>
            <select id="langHint">
              <option value="">Auto</option><option value="zh" selected>中文</option>
              <option value="de">Deutsch</option><option value="en">English</option>
              <option value="ja">日本語</option><option value="fr">Français</option><option value="es">Español</option>
            </select>
          </div>
          <div>
            <label>固定分段间隔 ms（低延迟用）</label>
            <input id="commitMs" type="number" min="300" max="2000" value="650" />
          </div>
          <div>
            <label>能量阈值 高/低</label>
            <div style="display:flex;gap:8px">
              <input id="thrHigh" type="number" step="0.001" min="0.005" max="0.08" value="0.018" />
              <input id="thrLow"  type="number" step="0.001" min="0.003" max="0.08" value="0.012" />
            </div>
          </div>
          <div>
            <label>软暂停/硬暂停 ms</label>
            <div style="display:flex;gap:8px">
              <input id="softPause" type="number" min="120" max="800" value="480" />
              <input id="hardPause" type="number" min="500" max="2000" value="1200" />
            </div>
          </div>
          <div>
            <label>最长连续片段 ms</label>
            <input id="maxRun" type="number" min="1500" max="7000" value="4800" />
          </div>
          <div>
            <label>TTS 输出（可选）</label>
            <select id="ttsVoice">
              <option value="" selected>禁用（仅转写/翻译）</option>
              <option>alloy</option><option>ash</option><option>ballad</option><option>coral</option>
              <option>echo</option><option>sage</option><option>shimmer</option><option>verse</option>
              <option>marin</option><option>cedar</option>
            </select>
          </div>

          <!-- —— 翻译相关 —— -->
          <div>
            <label>实时翻译</label>
            <select id="translateOn">
              <option value="on" selected>开启</option>
              <option value="off">关闭</option>
            </select>
          </div>
          <div>
            <label>目标语言</label>
            <select id="translateTarget">
              <option value="auto" selected>自动对向</option>
              <option value="zh">中文</option>
              <option value="de">Deutsch</option>
              <option value="en">English</option>
              <option value="ja">日本語</option>
              <option value="fr">Français</option>
              <option value="es">Español</option>
            </select>
          </div>
          <div>
            <label>近实时预览翻译</label>
            <select id="nearRealtime">
              <option value="on" selected>开启（边说边出临时译）</option>
              <option value="off">关闭（只句落地译）</option>
            </select>
          </div>
        </div>
      </details>

      <!-- 控制按钮 -->
      <div class="row btns">
        <button class="primary" id="btnStart">开始</button>
        <button class="ghost" id="btnToggle" disabled>暂停</button>
        <button class="ghost" id="btnStop" disabled>停止</button>
        <button class="ghost" id="btnCopyPreview" disabled>复制预览文本</button>
      </div>

      <!-- 唯一的实时文本预览框 + 复制 -->
      <label>实时文本预览（原文 + 译文，单窗口展示；译文自动插在原文下一行）</label>
      <div class="preview-wrap">
        <button class="copy-fab" id="btnCopyFab">复制</button>
        <textarea id="preview" class="mono" placeholder="开始后，这里将滚动显示你的长句实时转写与翻译…"></textarea>
      </div>

      <p class="muted small" id="presetNote">连贯建议：把 <b>软暂停</b> 450–520ms、<b>硬暂停</b> 1200–1400ms，或把 <b>高阈值</b> 提到 0.020。</p>

      <label>系统日志</label>
      <div class="log mono small" id="log"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const log = (msg, cls="") => { const p=document.createElement("div"); p.textContent=msg; if(cls)p.className=cls;
    $("log").appendChild(p); $("log").scrollTop=$("log").scrollHeight; };
  const setStatus = (txt) => $("status").textContent = txt;

  // —— 客户端检测（iPad 报 Mac 也能识别）——
  const ua = navigator.userAgent || "";
  const isIOS = /iPad|iPhone|iPod/i.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
  const isIpadMacUA = (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);

  // —— 参数预设（两套默认）——
  const PRESETS = {
    desktop: {
      mode: "smart",
      commitMs: 650,
      thrHigh: 0.018, thrLow: 0.012,
      softPause: 480, hardPause: 1200, maxRun: 4800,
      // 额外内部参数（不暴露UI）
      minCommitChars: 8,
      commitCooldownMs: 280,
      rt_vad: { threshold: 0.50, prefix_padding_ms: 300, silence_duration_ms: 600 }
    },
    ios: {
      mode: "smart",
      commitMs: 900,                        // 固定分段模式也更慢一些
      thrHigh: 0.024, thrLow: 0.016,        // iOS 上底噪/AGC 较强 -> 拉高阈值
      softPause: 680, hardPause: 1700, maxRun: 6200,  // 更“耐心”
      minCommitChars: 18,                    // 重要：不提交太短的碎片
      commitCooldownMs: 520,                 // 重要：提交冷却，抑制频繁 commit
      rt_vad: { threshold: 0.55, prefix_padding_ms: 350, silence_duration_ms: 900 }
    }
  };

  // —— 将预设写入 UI（仅作为初始值，用户改动仍生效）——
  const preset = isIOS ? PRESETS.ios : PRESETS.desktop;
  window.addEventListener("DOMContentLoaded", () => {
    $("mode").value = preset.mode;
    $("commitMs").value = preset.commitMs;
    $("thrHigh").value = preset.thrHigh;
    $("thrLow").value  = preset.thrLow;
    $("softPause").value = preset.softPause;
    $("hardPause").value = preset.hardPause;
    $("maxRun").value = preset.maxRun;

    const note = isIOS
      ? "已应用：iOS 优化预设（更少断句、更长片段）。如仍过短，可把“硬暂停”提到 1800–2000ms、把“高阈值”提到 0.026。"
      : "已应用：桌面预设（响应更快）。如句子太短，可把“硬暂停”提到 1400–1600ms 或“高阈值”到 0.020。";
    $("presetNote").textContent = note;

    // 状态栏小徽标
    const pill = document.createElement("span");
    pill.className = "pill";
    pill.textContent = isIOS ? "iOS 优化预设" : "桌面预设";
    document.querySelector(".title").appendChild(document.createTextNode(" "));
    document.querySelector(".title").appendChild(pill);
  });

  // WebRTC / Realtime
  let pc=null, dc=null, micStream=null, micTrack=null, ac=null, analyser=null, rafId=null;
  let ephemeralKey=null, paused=false, fixedTimer=null;

  // 语音状态
  let speaking=false, lastVoiceOnTs=0, lastVoiceOffTs=0, lastCommit=0;

  // 噪声自校准结果（动态阈值用）
  let noiseFloor = 0, dynHigh = 0, dynLow = 0;

  // 文本与翻译聚合
  const finalPairs = [];
  let liveSrc=""; let liveTgt="";
  let liveTransDebounce=null, liveTransReqId=0;

  // 运行时配置（含翻译）
  let cfg = {
    rtModel: "", sttModel: "", mode:"smart", langHint:"",
    ttsVoice:"", commitMs:650, thrHigh:0.018, thrLow:0.012, softPause:480, hardPause:1200, maxRun:4800,
    translateOn:true, translateTarget:"auto", nearRealtime:true, apiKey:"",
    // 额外内部参数
    minCommitChars: preset.minCommitChars,
    commitCooldownMs: preset.commitCooldownMs,
    rtVadPreset: preset.rt_vad
  };

  // 预览更新：把 finalPairs + live 组装成一个大文本
  const updatePreview = () => {
    const lines = [];
    for (const pair of finalPairs) {
      if (pair.src) lines.push(pair.src);
      if (cfg.translateOn) {
        if (pair.tgt) {
          lines.push("-" + pair.tgt);
          lines.push("");
        } else {
          lines.push("(处理中…)");
          lines.push("");
        }
      }
    }
    if (liveSrc) {
      lines.push(liveSrc);
      if (cfg.translateOn) {
        if (liveTgt) {
          lines.push("【译·临时】" + liveTgt);
          lines.push("");
        } else if (cfg.nearRealtime) {
          lines.push("【译·临时】(…)");
          lines.push("");
        }
      }
    }
    const full = lines.join("\n").trim();
    const el = $("preview");
    const stayBottom = (el.scrollTop + el.clientHeight + 8 >= el.scrollHeight);
    el.value = full;
    if (stayBottom) el.scrollTop = el.scrollHeight;
  };

  // 绑定按钮
  $("btnStart").onclick = start;
  $("btnToggle").onclick = togglePause;
  $("btnStop").onclick = stopAll;
  $("btnCopyPreview").onclick = copyPreview;
  $("btnCopyFab").onclick = copyPreview;

  async function start(){
    // 收 UI
    cfg.apiKey   = $("apiKey").value.trim();
    cfg.rtModel  = $("rtModel").value;
    cfg.sttModel = $("sttModel").value;
    cfg.mode     = $("mode").value;
    cfg.langHint = $("langHint").value;
    cfg.ttsVoice = $("ttsVoice").value;
    cfg.commitMs   = clamp(parseInt($("commitMs").value||String(preset.commitMs),10), 300, 2000);
    cfg.thrHigh    = clamp(parseFloat($("thrHigh").value||String(preset.thrHigh)), 0.005, 0.08);
    cfg.thrLow     = clamp(parseFloat($("thrLow").value ||String(preset.thrLow)), 0.003, 0.08);
    cfg.softPause  = clamp(parseInt($("softPause").value||String(preset.softPause),10), 120, 800);
    cfg.hardPause  = clamp(parseInt($("hardPause").value||String(preset.hardPause),10), 500, 2000);
    cfg.maxRun     = clamp(parseInt($("maxRun").value   ||String(preset.maxRun),10), 1500, 7000);
    cfg.translateOn     = $("translateOn").value === "on";
    cfg.translateTarget = $("translateTarget").value;
    cfg.nearRealtime    = $("nearRealtime").value === "on";
    cfg.minCommitChars  = preset.minCommitChars;
    cfg.commitCooldownMs= preset.commitCooldownMs;
    cfg.rtVadPreset     = preset.rt_vad;

    if(!cfg.apiKey){ alert("请先输入 OpenAI API Key"); return; }

    disableAll(true); setStatus("准备中…"); log("▶️ Start clicked");

    try{
      // 1) 获取临时密钥（Realtime）
      const body = { model: cfg.rtModel }; if (cfg.ttsVoice) body.voice = cfg.ttsVoice;
      const sessResp = await fetch("https://api.openai.com/v1/realtime/sessions", {
        method: "POST",
        headers: { "Authorization": `Bearer ${cfg.apiKey}`, "Content-Type":"application/json", "OpenAI-Beta":"realtime=v1" },
        body: JSON.stringify(body)
      });
      if(!sessResp.ok){ throw new Error("获取临时密钥失败: " + await sessResp.text()); }
      const sess = await sessResp.json();
      ephemeralKey = sess?.client_secret?.value;
      if(!ephemeralKey) throw new Error("未拿到临时密钥");
      log("✅ 临时密钥已获取","ok");

      // 2) WebRTC + DataChannel
      pc = new RTCPeerConnection();
      const audioEl = new Audio(); audioEl.autoplay = true;
      pc.ontrack = (e)=>{ audioEl.srcObject = e.streams[0]; };
      dc = pc.createDataChannel("oai-events");

      dc.onopen = () => {
        log("📡 DataChannel 打开");
        const rtTurn = (cfg.mode === "smart")
          ? { type:"server_vad",
              threshold: cfg.rtVadPreset.threshold,
              prefix_padding_ms: cfg.rtVadPreset.prefix_padding_ms,
              silence_duration_ms: cfg.rtVadPreset.silence_duration_ms,
              create_response:false, interrupt_response:true }
          : null;
        const sessionUpdate = {
          type: "session.update",
          session: {
            input_audio_transcription: { model: cfg.sttModel, ...(cfg.langHint ? { language: cfg.langHint } : {}) },
            turn_detection: rtTurn,
            modalities: ["text"]
          }
        };
        dc.send(JSON.stringify(sessionUpdate));
        log(`🔧 已发送 session.update（mode=${cfg.mode}；iOS=${isIOS}）`);
      };

      dc.onmessage = (ev) => { try{ handleRealtimeEvent(JSON.parse(ev.data)); }catch{} };

      // 3) 麦克风 + WebAudio RMS（iOS 友好约束）
      const audioConstraints = {
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: false   // iOS 未必生效，但尽量关（防 AGC 过强）
      };
      micStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
      micTrack = micStream.getAudioTracks()[0]; pc.addTrack(micTrack, micStream);

      // 4) AudioContext（iOS 有时需要手势后才能 resume）
      try {
        ac = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive", sampleRate: 48000 });
      } catch {
        ac = new (window.AudioContext || window.webkitAudioContext)();
      }
      const src = ac.createMediaStreamSource(micStream);
      analyser = ac.createAnalyser(); analyser.fftSize = 1024; src.connect(analyser);

      // 5) SDP 交换
      const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
      const rtcResp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(cfg.rtModel)}`, {
        method: "POST",
        headers: { "Authorization": `Bearer ${ephemeralKey}`, "Content-Type":"application/sdp", "OpenAI-Beta":"realtime=v1" },
        body: offer.sdp
      });
      if(!rtcResp.ok){ throw new Error("建立 WebRTC 失败: " + await rtcResp.text()); }
      const answer = { type:"answer", sdp: await rtcResp.text() }; await pc.setRemoteDescription(answer);

      // 6) 启动前快速底噪自校准（≈700ms）
      setStatus("校准中…"); log("🧪 噪声底噪自校准中（≈0.7s）");
      await calibrateNoiseFloor(720);
      log(`📏 底噪=${noiseFloor.toFixed(5)}，动态阈值 high=${dynHigh.toFixed(5)} / low=${dynLow.toFixed(5)}`);

      // 7) 能量循环 +（可选）固定微分段
      loopEnergy(cfg);
      if(cfg.mode === "fast"){ fixedTimer = setInterval(()=>{ if(!paused) safeCommitGuarded(); }, cfg.commitMs); }

      paused=false; setStatus("已连接 · 正在转写…");
      $("btnToggle").textContent="暂停"; $("btnToggle").disabled=false;
      $("btnStop").disabled=false; $("btnCopyPreview").disabled=false;
      log("🎧 就绪，实时文本将在预览框滚动显示");
    }catch(err){
      log("❌ " + err.message, "danger");
      setStatus("失败"); disableAll(false); cleanup();
    }
  }

  // 收到 Realtime 事件
  function handleRealtimeEvent(ev){
    const t = ev.type; if(!t) return;
    if(t === "conversation.item.input_audio_transcription.completed"){
      const text = (ev.transcript || "").trim(); if(!text) return;
      liveSrc = mergeText(liveSrc, text);

      // 近实时译文（可选，防抖）
      if (cfg.translateOn && cfg.nearRealtime) {
        if (liveTransDebounce) clearTimeout(liveTransDebounce);
        // iOS 上稍微更长一点，避免过度抖动
        const wait = isIOS ? 800 : 600;
        liveTransDebounce = setTimeout(() => {
          // 文本太短不译，避免闪烁
          if (liveSrc && liveSrc.length >= (isIOS ? 30 : 16)) {
            doLiveTranslate(liveSrc);
          }
        }, wait);
      }

      if (shouldFinalize(liveSrc)) finalizeLive();  // 句末/很长 -> 落地 & 译
      updatePreview();
    }else if(t === "session.created"){
      log("🟦 session.created");
    }else if(t === "error"){
      log("⚠️ Realtime 错误: " + (ev.error?.message || JSON.stringify(ev)), "warn");
    }
  }

  // 文本合并与落地
  function mergeText(prev, cur){
    const cjk = /[\u4E00-\u9FFF\u3040-\u30FF\uAC00-\uD7AF]/;
    const joiner = (cjk.test(prev) || cjk.test(cur)) ? "" : " ";
    if(!prev) return cur;
    const overlap = longestOverlapSuffixPrefix(prev, cur);
    const merged = prev + (overlap>0 ? cur.slice(overlap) : (joiner + cur));
    return merged.replace(/\s+/g," ").trim();
  }
  function longestOverlapSuffixPrefix(a,b){
    const max = Math.min(a.length, b.length, 24);
    for(let k=max;k>3;k--){ if(a.slice(-k).toLowerCase() === b.slice(0,k).toLowerCase()) return k; }
    return 0;
  }
  function shouldFinalize(text){
    if(/[。！？!?…．.]\s*$/.test(text)) return true;   // 句末标点
    // iOS 更“耐心”：长度阈值提高
    const lenCut = isIOS ? 120 : 100;
    if(text.length > lenCut && /\s$/.test(text)) return true; // 很长后允许落地
    return false;
  }
  function finalizeLive(){
    if(!liveSrc) return;
    const idx = finalPairs.length;
    finalPairs.push({ src: liveSrc, tgt: cfg.translateOn ? null : "" });
    liveSrc = ""; liveTgt = ""; // 清空 live
    updatePreview();
    // 句落地立即翻译
    if (cfg.translateOn) translateSegment(idx).catch(()=>{});
  }

  // —— 底噪自校准：估计 RMS 底噪并生成动态阈值 —— //
  async function calibrateNoiseFloor(ms=700){
    if(!analyser) return;
    const buf = new Float32Array(1024);
    const t0 = performance.now();
    let acc = 0, n = 0;
    while (performance.now() - t0 < ms) {
      analyser.getFloatTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; sum+=v*v; }
      const rms = Math.sqrt(sum/buf.length);
      acc += rms; n++;
      await new Promise(r=>setTimeout(r, 20));
    }
    noiseFloor = n>0 ? acc/n : 0;
    // 动态阈值 = max(手动阈值, 噪声×系数)
    const mulHigh = isIOS ? 3.5 : 3.0;
    const mulLow  = isIOS ? 2.4 : 2.0;
    dynHigh = Math.max(cfg.thrHigh, noiseFloor * mulHigh);
    dynLow  = Math.max(cfg.thrLow,  noiseFloor * mulLow);
  }

  // —— 能量检测 + 智能 commit（迟滞 + 软/硬暂停 + 最长片段 + 提交冷却 + 最短字数）——
  function loopEnergy(cfgLocal){
    const { mode, softPause, hardPause, maxRun } = cfgLocal;
    const buf = new Float32Array(1024);
    let ema = 0, alpha = 0.3;

    const tick = () => {
      if(!analyser) return;
      analyser.getFloatTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; sum+=v*v; }
      const rms = Math.sqrt(sum/buf.length);
      ema = alpha*rms + (1-alpha)*ema;

      // 使用“动态阈值”而不是固定阈值
      const high = dynHigh || cfg.thrHigh;
      const low  = dynLow  || cfg.thrLow;

      const now = performance.now();
      if(!speaking && ema > high){ speaking = true; lastVoiceOnTs = now; }
      if(speaking && ema < low){ speaking = false; lastVoiceOffTs = now; }

      if(mode === "smart" && !paused){
        // 条件1：静音超过 softPause，且满足最短字数/冷却 => 小结（但不 finalize）
        if(!speaking && (now - lastVoiceOffTs) > softPause){
          const cooldownOk = (now - lastCommit) > cfg.commitCooldownMs;
          const enoughText = (liveSrc && liveSrc.length >= cfg.minCommitChars);
          if ((cooldownOk && enoughText) || (now - lastVoiceOffTs) > (hardPause + 150)) {
            safeCommitGuarded(); lastCommit = now;
          }
        }
        // 条件2：说太久，切一刀
        if(speaking && (now - lastVoiceOnTs) > maxRun && (now - lastCommit) > cfg.commitCooldownMs){
          safeCommitGuarded(); lastCommit = now;
        }
        // 条件3：长硬暂停 => 强制 finalize（即使没标点）
        if(!speaking && (now - lastVoiceOffTs) > hardPause && (finalPairs.length>0 || liveSrc)){
          if (liveSrc) finalizeLive();
        }
      }
      rafId = requestAnimationFrame(tick);
    };
    tick();
  }

  // 受保护的 commit（带 try/catch 与小日志）
  function safeCommitGuarded(){
    try{
      dc && dc.send(JSON.stringify({ type:"input_audio_buffer.commit" }));
      //log("· commit", "muted"); // 如需观察节流可打开
    }catch(e){
      // 静默
    }
  }
  const safeCommit = safeCommitGuarded; // 兼容旧调用

  // —— 翻译 —— //
  function pickTargetLanguage(){
    if (cfg.translateTarget !== "auto") return cfg.translateTarget;
    // 自动对向：若正在用中文转写 => 译成德语；若德/英 => 译成中文；其它 => 英文
    if (cfg.langHint === "zh") return "de";
    if (cfg.langHint === "de" || cfg.langHint === "en") return "zh";
    return "en";
  }

  async function doLiveTranslate(text){
    const reqId = ++liveTransReqId;
    try{
      const tgt = await translateText(text, pickTargetLanguage());
      if (reqId === liveTransReqId) {
        liveTgt = tgt;
        updatePreview();
      }
    }catch(e){ /* 静默失败 */ }
  }

  async function translateSegment(index){
    const src = finalPairs[index]?.src || "";
    if (!src) return;
    try{
      const tgt = await translateText(src, pickTargetLanguage());
      finalPairs[index].tgt = tgt;
      updatePreview();
    }catch(e){
      finalPairs[index].tgt = "(翻译失败：" + (e.message||"") + ")";
      updatePreview();
      log("⚠️ 段落翻译失败: " + e.message, "warn");
    }
  }

  async function translateText(text, targetLang){
    const resp = await fetch("https://api.openai.com/v1/chat/completions",{
      method:"POST",
      headers:{ "Authorization":`Bearer ${cfg.apiKey}`, "Content-Type":"application/json" },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        temperature: 0.2,
        messages: [
          { role:"system", content:
            `You are a high-quality, low-latency translator. 
             Translate the user's text into ${targetLang}.
             Requirements: faithful, fluent, keep punctuation, no extra comments, no brackets, no quotes.
             If the text seems partial, still translate what's available.`},
          { role:"user", content: text }
        ]
      })
    });
    if(!resp.ok){
      const t = await resp.text();
      throw new Error("翻译接口错误：" + t);
    }
    const data = await resp.json();
    const out = data?.choices?.[0]?.message?.content || "";
    return (out||"").trim();
  }

  // 控制与工具
  function togglePause(){
    if(!micTrack) return;
    if(!paused){
      micTrack.enabled=false; paused=true; safeCommit();
      setStatus("已暂停 · 不再采集音频"); $("btnToggle").textContent="继续"; log("⏸️ 已暂停麦克风");
    }else{
      micTrack.enabled=true; paused=false;
      setStatus("已连接 · 正在转写…"); $("btnToggle").textContent="暂停"; log("▶️ 继续采集麦克风");
    }
  }
  function copyPreview(){
    const text = $("preview").value || "";
    navigator.clipboard.writeText(text)
      .then(()=>log("📋 已复制：预览文本","ok"))
      .catch(e=>log("复制失败: "+e.message,"warn"));
  }
  function stopAll(){ setStatus("已停止"); log("⏹️ 停止"); disableAll(false); cleanup(); }
  function disableAll(working){
    $("btnStart").disabled = working; $("btnToggle").disabled = true;
    $("btnStop").disabled = !working; $("btnCopyPreview").disabled = true;
  }
  function cleanup(){
    if(fixedTimer){ clearInterval(fixedTimer); fixedTimer=null; }
    if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
    try{ dc && dc.close(); }catch{} try{ pc && pc.close(); }catch{}
    try{ micTrack && micTrack.stop(); }catch{}
    try{ micStream && micStream.getTracks().forEach(t=>t.stop()); }catch{}
    if(ac){ try{ ac.close(); }catch{} ac=null; }
    pc=null; dc=null; micTrack=null; micStream=null; analyser=null; ephemeralKey=null; paused=false;
    speaking=false; noiseFloor=0; dynHigh=0; dynLow=0;
    finalPairs.length=0; liveSrc=""; liveTgt="";
    updatePreview();
  }

  // 工具函数
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
})();
</script>
</body>
</html>
