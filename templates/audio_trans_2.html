<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>å®æ—¶è¯­éŸ³è½¬å†™ + å®æ—¶ç¿»è¯‘ Â· è‡ªé€‚åº”å¹³è¡¡ç‰ˆ</title>
<style>
  :root{--bg:#0b1020;--panel:#111936;--text:#e7ecff;--muted:#93a4c3;--line:#1f2a4d;
    --brand:#7c9dfc;--ok:#22c55e;--warn:#f59e0b;--danger:#ef4444;--shadow:0 20px 50px rgba(3,8,23,.4)}
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b1020,#0f1530 60%,#0b1020);color:var(--text);
       font:15px/1.6 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
  .card{background:linear-gradient(180deg,#0f1633,#0e1630);border:1px solid var(--line);border-radius:16px;box-shadow:var(--shadow)}
  .header{padding:16px 20px;border-bottom:1px solid var(--line);display:flex;gap:12px;align-items:center;justify-content:space-between}
  .title{font-size:18px;font-weight:700;letter-spacing:.2px}
  .pill{border:1px solid var(--line);color:var(--muted);padding:4px 8px;border-radius:999px;font-size:12px}
  .body{padding:16px 20px}
  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin:12px 0}
  .row > *{flex:1}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input,select,button,textarea{background:#0b122b;border:1px solid var(--line);color:var(--text);
    border-radius:10px;padding:10px 12px;outline:none}
  input::placeholder{color:#6b7280}
  select{cursor:pointer}
  button{cursor:pointer;transition:.15s ease;border:1px solid #2a3870}
  button.primary{background:linear-gradient(180deg,#4f6df7,#4a61e6);border:none}
  button.ghost{background:#0b122b}
  button:disabled{opacity:.6;cursor:not-allowed}
  .btns{display:flex;gap:10px;flex-wrap:wrap}
  .status{font-size:13px;color:var(--muted)}
  .log{background:#0b122b;border:1px dashed #213069;border-radius:12px;padding:12px;height:160px;overflow:auto}
  .preview-wrap{position:relative;margin-top:6px}
  #preview{width:100%;height:560px;resize:vertical}
  .copy-fab{position:absolute;right:8px;top:8px;background:#101a3b;border:1px solid #2a3870;border-radius:8px;padding:6px 10px;font-size:12px}
  details.settings{margin:14px 0;border:1px solid var(--line);border-radius:12px;overflow:hidden}
  details.settings[open]{box-shadow:var(--shadow)}
  details.settings summary{list-style:none;cursor:pointer;background:#0d1534;padding:12px 14px;display:flex;align-items:center;gap:10px;
    user-select:none;border-bottom:1px solid var(--line)}
  details.settings summary::-webkit-details-marker{display:none}
  .chev{width:10px;height:10px;border-right:2px solid #7c9dfc;border-bottom:2px solid #7c9dfc;transform:rotate(-45deg);transition:.2s}
  details.settings[open] .chev{transform:rotate(45deg)}
  .controls{padding:14px;display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  @media (max-width:1000px){.controls{grid-template-columns:1fr}}
  .small{font-size:12px} .muted{color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="header">
      <div class="title">å®æ—¶è¯­éŸ³è½¬å†™ <span class="pill">æ™ºèƒ½åˆ†å¥ Â· å®æ—¶ç¿»è¯‘ Â· è‡ªé€‚åº”</span></div>
      <div class="status" id="status">æœªè¿æ¥</div>
    </div>

    <div class="body">
      <!-- é¡¶éƒ¨æ ¸å¿ƒè¾“å…¥ -->
      <div class="row">
        <div>
          <label>OpenAI API Keyï¼ˆæœ¬åœ°è°ƒè¯•ç”¨ï¼›çº¿ä¸Šæ”¹ä¸ºåç«¯ç­¾å‘ä¸´æ—¶å¯†é’¥ï¼‰</label>
          <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
        </div>
        <div>
          <label>Realtime ä¼šè¯æ¨¡å‹</label>
          <select id="rtModel">
            <option value="gpt-4o-mini-realtime-preview-2024-12-17" selected>gpt-4o-mini-realtime</option>
            <option value="gpt-4o-realtime-preview-2024-12-17">gpt-4o-realtime</option>
          </select>
        </div>
        <div>
          <label>è½¬å†™æ¨¡å‹</label>
          <select id="sttModel">
            <option value="gpt-4o-mini-transcribe" selected>gpt-4o-mini-transcribe</option>
            <option value="gpt-4o-transcribe">gpt-4o-transcribe</option>
          </select>
        </div>
      </div>

      <!-- å¯æŠ˜å å‚æ•°ï¼ˆé»˜è®¤æ”¶èµ·ï¼‰ -->
      <details class="settings">
        <summary><span class="chev"></span><b>å‚æ•°è®¾ç½®ï¼ˆå¯æ”¶èµ·/å±•å¼€ï¼‰</b><span class="muted small"> Â· æ–­å¥/å»¶è¿Ÿ/ç¿»è¯‘</span></summary>
        <div class="controls">
          <div>
            <label>åˆ†å¥æ¨¡å¼</label>
            <select id="mode">
              <option value="smart" selected>æ™ºèƒ½åˆ†å¥ï¼ˆé»˜è®¤ï¼‰</option>
              <option value="fast">ä½å»¶è¿Ÿï¼ˆå›ºå®šé—´éš”å¾®åˆ†æ®µï¼‰</option>
            </select>
          </div>
          <div>
            <label>è½¬å†™è¯­è¨€æç¤º</label>
            <select id="langHint">
              <option value="">Auto</option><option value="zh" selected>ä¸­æ–‡</option>
              <option value="de">Deutsch</option><option value="en">English</option>
              <option value="ja">æ—¥æœ¬èª</option><option value="fr">FranÃ§ais</option><option value="es">EspaÃ±ol</option>
            </select>
          </div>
          <div>
            <label>å›ºå®šåˆ†æ®µé—´éš” msï¼ˆä½å»¶è¿Ÿç”¨ï¼‰</label>
            <input id="commitMs" type="number" min="300" max="2000" value="600" />
          </div>
          <div>
            <label>èƒ½é‡é˜ˆå€¼ é«˜/ä½</label>
            <div style="display:flex;gap:8px">
              <input id="thrHigh" type="number" step="0.001" min="0.005" max="0.08" value="0.019" />
              <input id="thrLow"  type="number" step="0.001" min="0.003" max="0.08" value="0.013" />
            </div>
          </div>
          <div>
            <label>è½¯æš‚åœ/ç¡¬æš‚åœ ms</label>
            <div style="display:flex;gap:8px">
              <input id="softPause" type="number" min="300" max="900" value="460" />
              <input id="hardPause" type="number" min="900" max="2200" value="1350" />
            </div>
          </div>
          <div>
            <label>æœ€é•¿è¿ç»­ç‰‡æ®µ ms</label>
            <input id="maxRun" type="number" min="2000" max="8000" value="5200" />
          </div>
          <div>
            <label>TTS è¾“å‡ºï¼ˆå¯é€‰ï¼‰</label>
            <select id="ttsVoice">
              <option value="" selected>ç¦ç”¨ï¼ˆä»…è½¬å†™/ç¿»è¯‘ï¼‰</option>
              <option>alloy</option><option>ash</option><option>ballad</option><option>coral</option>
              <option>echo</option><option>sage</option><option>shimmer</option><option>verse</option>
              <option>marin</option><option>cedar</option>
            </select>
          </div>

          <!-- â€”â€” ç¿»è¯‘ç›¸å…³ â€”â€” -->
          <div>
            <label>å®æ—¶ç¿»è¯‘</label>
            <select id="translateOn">
              <option value="on" selected>å¼€å¯</option>
              <option value="off">å…³é—­</option>
            </select>
          </div>
          <div>
            <label>ç›®æ ‡è¯­è¨€</label>
            <select id="translateTarget">
              <option value="auto" selected>è‡ªåŠ¨å¯¹å‘</option>
              <option value="zh">ä¸­æ–‡</option>
              <option value="de">Deutsch</option>
              <option value="en">English</option>
              <option value="ja">æ—¥æœ¬èª</option>
              <option value="fr">FranÃ§ais</option>
              <option value="es">EspaÃ±ol</option>
            </select>
          </div>
          <div>
            <label>è¿‘å®æ—¶é¢„è§ˆç¿»è¯‘</label>
            <select id="nearRealtime">
              <option value="on" selected>å¼€å¯ï¼ˆè¾¹è¯´è¾¹å‡ºä¸´æ—¶è¯‘ï¼‰</option>
              <option value="off">å…³é—­ï¼ˆåªå¥è½åœ°è¯‘ï¼‰</option>
            </select>
          </div>
        </div>
      </details>

      <!-- æ§åˆ¶æŒ‰é’® -->
      <div class="row btns">
        <button class="primary" id="btnStart">å¼€å§‹</button>
        <button class="ghost" id="btnToggle" disabled>æš‚åœ</button>
        <button class="ghost" id="btnStop" disabled>åœæ­¢</button>
        <button class="ghost" id="btnCopyPreview" disabled>å¤åˆ¶é¢„è§ˆæ–‡æœ¬</button>
      </div>

      <!-- å”¯ä¸€çš„å®æ—¶æ–‡æœ¬é¢„è§ˆæ¡† + å¤åˆ¶ -->
      <label>å®æ—¶æ–‡æœ¬é¢„è§ˆï¼ˆåŸæ–‡ + è¯‘æ–‡ï¼Œå•çª—å£å±•ç¤ºï¼›è¯‘æ–‡è‡ªåŠ¨æ’åœ¨åŸæ–‡ä¸‹ä¸€è¡Œï¼‰</label>
      <div class="preview-wrap">
        <button class="copy-fab" id="btnCopyFab">å¤åˆ¶</button>
        <textarea id="preview" class="mono" placeholder="å¼€å§‹åï¼Œè¿™é‡Œå°†æ»šåŠ¨æ˜¾ç¤ºä½ çš„é•¿å¥å®æ—¶è½¬å†™ä¸ç¿»è¯‘â€¦"></textarea>
      </div>

      <p class="muted small" id="presetNote"></p>

      <label>ç³»ç»Ÿæ—¥å¿—</label>
      <div class="log mono small" id="log"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const log = (msg, cls="") => { const p=document.createElement("div"); p.textContent=msg; if(cls)p.className=cls;
    $("log").appendChild(p); $("log").scrollTop=$("log").scrollHeight; };
  const setStatus = (txt) => $("status").textContent = txt;

  // â€”â€” å®¢æˆ·ç«¯æ£€æµ‹ï¼ˆiPad æŠ¥ Mac ä¹Ÿèƒ½è¯†åˆ«ï¼‰â€”â€”
  const ua = navigator.userAgent || "";
  const isIOS = /iPad|iPhone|iPod/i.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);

  // â€”â€” å¹³è¡¡ç‰ˆä¸¤å¥—èµ·å§‹é¢„è®¾ â€”â€” //
  const PRESETS = {
    desktop: {
      mode: "smart",
      commitMs: 600,
      thrHigh: 0.019, thrLow: 0.013,
      softPause: 460, hardPause: 1350, maxRun: 5200,
      minCommitChars: 14,
      commitCooldownMs: 340,
      minBufferedBeforeCommitMs: 160, // å§‹ç»ˆ â‰¥100msï¼ˆå®‰å…¨ä½™é‡ï¼‰
      rt_vad: { threshold: 0.50, prefix_padding_ms: 300, silence_duration_ms: 800 }
    },
    ios: {
      mode: "smart",
      commitMs: 750,
      thrHigh: 0.022, thrLow: 0.015,
      softPause: 560, hardPause: 1600, maxRun: 5600,
      minCommitChars: 18,
      commitCooldownMs: 420,
      minBufferedBeforeCommitMs: 180, // iOS ç»™æ›´å¤§ä½™é‡
      rt_vad: { threshold: 0.54, prefix_padding_ms: 340, silence_duration_ms: 950 }
    }
  };
  const preset = isIOS ? PRESETS.ios : PRESETS.desktop;

  // â€”â€” å°†é¢„è®¾å†™å…¥ UI â€”â€” //
  window.addEventListener("DOMContentLoaded", () => {
    $("mode").value = preset.mode;
    $("commitMs").value = preset.commitMs;
    $("thrHigh").value = preset.thrHigh;
    $("thrLow").value  = preset.thrLow;
    $("softPause").value = preset.softPause;
    $("hardPause").value = preset.hardPause;
    $("maxRun").value = preset.maxRun;

    const pill = document.createElement("span");
    pill.className = "pill";
    pill.textContent = isIOS ? "iOS å¹³è¡¡é¢„è®¾ + è‡ªé€‚åº”" : "æ¡Œé¢å¹³è¡¡é¢„è®¾ + è‡ªé€‚åº”";
    document.querySelector(".title").appendChild(document.createTextNode(" "));
    document.querySelector(".title").appendChild(pill);

    $("presetNote").textContent = "è‡ªé€‚åº”æ§åˆ¶å™¨æ¯ 6 ç§’å¾®è°ƒä¸€æ¬¡ï¼šè‹¥ç‰‡æ®µè¿‡çŸ­â†’ç¨å¾®å»¶é•¿æš‚åœ/æé«˜æœ€å°æäº¤å­—æ•°ï¼›è‹¥è¿‡é•¿â†’ç¼©çŸ­æš‚åœ/é™ä½å­—æ•°ã€‚";
  });

  // â€”â€” WebRTC / Realtime â€”â€” //
  let pc=null, dc=null, micStream=null, micTrack=null, ac=null, analyser=null, rafId=null;
  let ephemeralKey=null, paused=false, fixedTimer=null;

  // è¯­éŸ³çŠ¶æ€
  let speaking=false, lastVoiceOnTs=0, lastVoiceOffTs=0;

  // æäº¤è°ƒåº¦
  let firstAudioTs=0, lastCommitTs=0, pendingCommitTimer=null, commitRequested=false, startedStreaming=false;

  // å™ªå£°é˜ˆå€¼
  let noiseFloor=0, dynHigh=0, dynLow=0;

  // æ–‡æœ¬ä¸ç¿»è¯‘
  const finalPairs=[]; let liveSrc=""; let liveTgt=""; let liveTransDebounce=null, liveTransReqId=0;

  // è¿è¡Œæ—¶é…ç½®
  let cfg = {
    rtModel:"", sttModel:"", mode:"smart", langHint:"",
    ttsVoice:"", commitMs:preset.commitMs, thrHigh:preset.thrHigh, thrLow:preset.thrLow,
    softPause:preset.softPause, hardPause:preset.hardPause, maxRun:preset.maxRun,
    translateOn:true, translateTarget:"auto", nearRealtime:true, apiKey:"",
    minCommitChars: preset.minCommitChars,
    commitCooldownMs: preset.commitCooldownMs,
    minBufferedBeforeCommitMs: preset.minBufferedBeforeCommitMs,
    rtVadPreset: { ...preset.rt_vad }   // å¯è¢«è‡ªé€‚åº”æ›´æ–°
  };

  // â€”â€” è‡ªé€‚åº”æ§åˆ¶å™¨æŒ‡æ ‡ â€”â€” //
  const metrics = { commits:0, finals:0, finalChars:0, tooSmallErrors:0, lastEval:0 };
  let adaptTimer=null;

  // é¢„è§ˆ
  const updatePreview = () => {
    const lines=[];
    for(const pair of finalPairs){
      if(pair.src) lines.push(pair.src);
      if(cfg.translateOn){
        if(pair.tgt){ lines.push("-"+pair.tgt); lines.push(""); }
        else { lines.push("(å¤„ç†ä¸­â€¦)"); lines.push(""); }
      }
    }
    if(liveSrc){
      lines.push(liveSrc);
      if(cfg.translateOn){
        if(liveTgt){ lines.push("ã€è¯‘Â·ä¸´æ—¶ã€‘"+liveTgt); lines.push(""); }
        else if(cfg.nearRealtime){ lines.push("ã€è¯‘Â·ä¸´æ—¶ã€‘(â€¦)"); lines.push(""); }
      }
    }
    const full=lines.join("\n").trim();
    const el=$("preview");
    const stayBottom=(el.scrollTop+el.clientHeight+8>=el.scrollHeight);
    el.value=full; if(stayBottom) el.scrollTop=el.scrollHeight;
  };

  // ç»‘å®š
  $("btnStart").onclick = start;
  $("btnToggle").onclick = togglePause;
  $("btnStop").onclick = stopAll;
  $("btnCopyPreview").onclick = copyPreview;
  $("btnCopyFab").onclick = copyPreview;

  async function start(){
    cfg.apiKey   = $("apiKey").value.trim();
    cfg.rtModel  = $("rtModel").value;
    cfg.sttModel = $("sttModel").value;
    cfg.mode     = $("mode").value;
    cfg.langHint = $("langHint").value;
    cfg.ttsVoice = $("ttsVoice").value;
    cfg.commitMs   = clamp(parseInt($("commitMs").value||String(preset.commitMs),10), 300, 2000);
    cfg.thrHigh    = clamp(parseFloat($("thrHigh").value||String(preset.thrHigh)), 0.005, 0.08);
    cfg.thrLow     = clamp(parseFloat($("thrLow").value ||String(preset.thrLow)), 0.003, 0.08);
    cfg.softPause  = clamp(parseInt($("softPause").value||String(preset.softPause),10), 300, 900);
    cfg.hardPause  = clamp(parseInt($("hardPause").value||String(preset.hardPause),10), 900, 2200);
    cfg.maxRun     = clamp(parseInt($("maxRun").value   ||String(preset.maxRun),10), 2000, 8000);
    cfg.translateOn     = $("translateOn").value === "on";
    cfg.translateTarget = $("translateTarget").value;
    cfg.nearRealtime    = $("nearRealtime").value === "on";
    cfg.minCommitChars  = preset.minCommitChars;
    cfg.commitCooldownMs= preset.commitCooldownMs;
    cfg.minBufferedBeforeCommitMs = preset.minBufferedBeforeCommitMs;
    cfg.rtVadPreset     = { ...preset.rt_vad };

    if(!cfg.apiKey){ alert("è¯·å…ˆè¾“å…¥ OpenAI API Key"); return; }

    disableAll(true); setStatus("å‡†å¤‡ä¸­â€¦"); log("â–¶ï¸ Start clicked");

    try{
      // Realtime session
      const body = { model: cfg.rtModel }; if(cfg.ttsVoice) body.voice = cfg.ttsVoice;
      const sessResp = await fetch("https://api.openai.com/v1/realtime/sessions", {
        method: "POST",
        headers: { "Authorization": `Bearer ${cfg.apiKey}`, "Content-Type":"application/json", "OpenAI-Beta":"realtime=v1" },
        body: JSON.stringify(body)
      });
      if(!sessResp.ok){ throw new Error("è·å–ä¸´æ—¶å¯†é’¥å¤±è´¥: " + await sessResp.text()); }
      const sess = await sessResp.json();
      ephemeralKey = sess?.client_secret?.value;
      if(!ephemeralKey) throw new Error("æœªæ‹¿åˆ°ä¸´æ—¶å¯†é’¥");
      log("âœ… ä¸´æ—¶å¯†é’¥å·²è·å–","ok");

      // WebRTC + DC
      pc = new RTCPeerConnection();
      const audioEl = new Audio(); audioEl.autoplay=true;
      pc.ontrack = (e)=>{ audioEl.srcObject=e.streams[0]; };
      dc = pc.createDataChannel("oai-events");

      dc.onopen = () => {
        log("ğŸ“¡ DataChannel æ‰“å¼€");
        sendSessionUpdate(); // é¦–æ¬¡åº”ç”¨ turn_detection
      };
      dc.onmessage = (ev)=>{ try{ handleRealtimeEvent(JSON.parse(ev.data)); }catch{} };

      // Mic & AudioContext
      const audioConstraints = { channelCount:1, echoCancellation:true, noiseSuppression:true, autoGainControl:false };
      micStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
      micTrack = micStream.getAudioTracks()[0]; pc.addTrack(micTrack, micStream);

      try{ ac = new (window.AudioContext||window.webkitAudioContext)({ latencyHint:"interactive", sampleRate:48000 }); }
      catch{ ac = new (window.AudioContext||window.webkitAudioContext)(); }
      const src = ac.createMediaStreamSource(micStream);
      analyser = ac.createAnalyser(); analyser.fftSize=1024; src.connect(analyser);

      // SDP
      const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
      const rtcResp = await fetch(`https://api.openai.com/v1/realtime?model=${encodeURIComponent(cfg.rtModel)}`, {
        method:"POST",
        headers:{ "Authorization":`Bearer ${ephemeralKey}`, "Content-Type":"application/sdp", "OpenAI-Beta":"realtime=v1" },
        body: offer.sdp
      });
      if(!rtcResp.ok){ throw new Error("å»ºç«‹ WebRTC å¤±è´¥: " + await rtcResp.text()); }
      const answer = { type:"answer", sdp: await rtcResp.text() }; await pc.setRemoteDescription(answer);

      // å™ªå£°åº•å™ªæ ¡å‡†
      setStatus("æ ¡å‡†ä¸­â€¦"); log("ğŸ§ª å™ªå£°åº•å™ªè‡ªæ ¡å‡†ï¼ˆ~0.7sï¼‰");
      await calibrateNoiseFloor(720);
      log(`ğŸ“ åº•å™ª=${noiseFloor.toFixed(5)} åŠ¨æ€é˜ˆ high=${dynHigh.toFixed(5)} low=${dynLow.toFixed(5)}`);

      firstAudioTs = performance.now(); startedStreaming = true;

      // å¯åŠ¨èƒ½é‡å¾ªç¯ & è‡ªé€‚åº”å¾ªç¯
      loopEnergy(cfg);
      if(cfg.mode === "fast"){ fixedTimer=setInterval(()=>{ if(!paused) requestCommit("timer"); }, cfg.commitMs); }

      // è¯„ä¼°çª—å£åˆå§‹åŒ– & å®šæ—¶è‡ªé€‚åº”
      metrics.lastEval = performance.now();
      adaptTimer = setInterval(adaptOnce, 6000);

      paused=false; setStatus("å·²è¿æ¥ Â· æ­£åœ¨è½¬å†™â€¦");
      $("btnToggle").textContent="æš‚åœ"; $("btnToggle").disabled=false;
      $("btnStop").disabled=false; $("btnCopyPreview").disabled=false;
      log("ğŸ§ å°±ç»ªï¼Œå®æ—¶æ–‡æœ¬å°†åœ¨é¢„è§ˆæ¡†æ»šåŠ¨æ˜¾ç¤º");
    }catch(err){
      log("âŒ " + err.message, "danger");
      setStatus("å¤±è´¥"); disableAll(false); cleanup();
    }
  }

  // â€”â€” å‘é€/æ›´æ–° Realtime ä¼šè¯å‚æ•°ï¼ˆæœåŠ¡ç«¯ VADï¼‰â€”â€”
  function sendSessionUpdate(){
    if(!dc) return;
    const rtTurn = (cfg.mode === "smart")
      ? { type:"server_vad",
          threshold: cfg.rtVadPreset.threshold,
          prefix_padding_ms: cfg.rtVadPreset.prefix_padding_ms,
          silence_duration_ms: cfg.rtVadPreset.silence_duration_ms,
          create_response:false, interrupt_response:true }
      : null;
    dc.send(JSON.stringify({
      type:"session.update",
      session:{
        input_audio_transcription:{ model: cfg.sttModel, ...(cfg.langHint ? { language: cfg.langHint } : {}) },
        turn_detection: rtTurn,
        modalities:["text"]
      }
    }));
    log(`ğŸ”§ session.update: silence=${cfg.rtVadPreset.silence_duration_ms}ms, thr=${cfg.rtVadPreset.threshold}`);
  }

  // â€”â€” ç»Ÿä¸€äº‹ä»¶ â€”â€” //
  function handleRealtimeEvent(ev){
    const t = ev.type; if(!t) return;
    if(t === "conversation.item.input_audio_transcription.completed"){
      const text=(ev.transcript||"").trim(); if(!text) return;
      liveSrc = mergeText(liveSrc, text);

      // è¿‘å®æ—¶ç¿»è¯‘ï¼ˆè½»é˜²æŠ–ï¼‰
      if (cfg.translateOn && cfg.nearRealtime) {
        if (liveTransDebounce) clearTimeout(liveTransDebounce);
        const wait = isIOS ? 600 : 450; // å¹³è¡¡
        liveTransDebounce = setTimeout(() => {
          if (liveSrc && liveSrc.length >= (isIOS ? 26 : 16)) doLiveTranslate(liveSrc);
        }, wait);
      }

      if (shouldFinalize(liveSrc)) finalizeLive();
      updatePreview();
    } else if (t === "error"){
      const msg = (ev.error?.message || "").toLowerCase();
      if (msg.includes("buffer too smal") || msg.includes("buffer too small")) {
        metrics.tooSmallErrors++;
        // ç«‹åˆ»åŠ å¤§ minBufferedï¼Œç¡®ä¿ç¨³å®š
        cfg.minBufferedBeforeCommitMs = Math.min(cfg.minBufferedBeforeCommitMs + 20, 220);
        log(`ğŸ›¡ï¸ auto-guard: minBufferedBeforeCommitMs â†’ ${cfg.minBufferedBeforeCommitMs}`, "warn");
      }
      log("âš ï¸ Realtime é”™è¯¯: " + (ev.error?.message || JSON.stringify(ev)), "warn");
    } else if (t === "session.created"){
      log("ğŸŸ¦ session.created");
    }
  }

  // â€”â€” æ–‡æœ¬åˆå¹¶ä¸è½åœ° â€”â€” //
  function mergeText(prev, cur){
    const cjk=/[\u4E00-\u9FFF\u3040-\u30FF\uAC00-\uD7AF]/;
    const joiner=(cjk.test(prev)||cjk.test(cur))?"":" ";
    if(!prev) return cur;
    const overlap=longestOverlapSuffixPrefix(prev,cur);
    const merged=prev+(overlap>0?cur.slice(overlap):(joiner+cur));
    return merged.replace(/\s+/g," ").trim();
  }
  function longestOverlapSuffixPrefix(a,b){
    const max=Math.min(a.length,b.length,24);
    for(let k=max;k>3;k--){ if(a.slice(-k).toLowerCase()===b.slice(0,k).toLowerCase()) return k; }
    return 0;
  }
  function shouldFinalize(text){
    if(/[ã€‚ï¼ï¼Ÿ!?â€¦ï¼.]\s*$/.test(text)) return true;
    const lenCut=isIOS?125:115; // ä¸­é—´å€¼
    if(text.length>lenCut && /\s$/.test(text)) return true;
    return false;
  }
  function finalizeLive(){
    if(!liveSrc) return;
    const idx=finalPairs.length;
    finalPairs.push({ src: liveSrc, tgt: cfg.translateOn ? null : "" });
    metrics.finals++; metrics.finalChars += liveSrc.length;
    liveSrc=""; liveTgt="";
    updatePreview();
    if(cfg.translateOn) translateSegment(idx).catch(()=>{});
  }

  // â€”â€” å™ªå£°åº•å™ªè‡ªæ ¡å‡† â€”â€” //
  async function calibrateNoiseFloor(ms=700){
    if(!analyser) return;
    const buf=new Float32Array(1024);
    const t0=performance.now();
    let acc=0,n=0;
    while(performance.now()-t0<ms){
      analyser.getFloatTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; sum+=v*v; }
      const rms=Math.sqrt(sum/buf.length);
      acc+=rms; n++;
      await new Promise(r=>setTimeout(r,20));
    }
    noiseFloor = n>0 ? acc/n : 0;
    const mulHigh=isIOS?3.5:3.2, mulLow=isIOS?2.4:2.2; // ä¸­æ€§å€æ•°
    dynHigh=Math.max(cfg.thrHigh, noiseFloor*mulHigh);
    dynLow =Math.max(cfg.thrLow,  noiseFloor*mulLow);
  }

  // â€”â€” èƒ½é‡å¾ªç¯ & æ™ºèƒ½æäº¤ â€”â€” //
  function loopEnergy(cfgLocal){
    const { mode, softPause, hardPause, maxRun }=cfgLocal;
    const buf=new Float32Array(1024);
    let ema=0, alpha=0.3;

    const tick=()=>{
      if(!analyser) return;
      analyser.getFloatTimeDomainData(buf);
      let sum=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; sum+=v*v; }
      const rms=Math.sqrt(sum/buf.length);
      ema=alpha*rms+(1-alpha)*ema;

      const high=dynHigh||cfg.thrHigh, low=dynLow||cfg.thrLow;
      const now=performance.now();

      if(!speaking && ema>high){ speaking=true; lastVoiceOnTs=now; }
      if(speaking && ema<low){ speaking=false; lastVoiceOffTs=now; }

      if(mode==="smart" && !paused){
        if(!speaking && (now-lastVoiceOffTs)>cfg.softPause){
          const enoughText = (liveSrc && liveSrc.length>=cfg.minCommitChars);
          const longQuiet  = (now-lastVoiceOffTs)>(cfg.hardPause+120);
          if(enoughText || longQuiet){ requestCommit("softPause"); }
        }
        if(speaking && (now-lastVoiceOnTs)>cfg.maxRun){ requestCommit("maxRun"); }
        if(!speaking && (now-lastVoiceOffTs)>cfg.hardPause && (finalPairs.length>0 || liveSrc)){
          if(liveSrc) finalizeLive();
        }
      }
      rafId=requestAnimationFrame(tick);
    };
    tick();
  }

  // â€”â€” æäº¤è°ƒåº¦å™¨ï¼ˆä¿è¯ â‰¥100ms ç¼“å†² + å†·å´ + åˆå¹¶ï¼‰â€”â€” //
  function requestCommit(reason=""){
    const now=performance.now();
    if(!startedStreaming){ scheduleCommit(cfg.minBufferedBeforeCommitMs, reason+"(notStarted)"); return; }
    const sinceFirst = now - (firstAudioTs||now);
    const sinceLast  = now - (lastCommitTs||0);
    const need1 = cfg.minBufferedBeforeCommitMs - sinceFirst;
    const need2 = cfg.minBufferedBeforeCommitMs - sinceLast;
    const need3 = cfg.commitCooldownMs - sinceLast;
    const wait = Math.max(need1, need2, need3, 0);
    if(wait>0){ scheduleCommit(wait, reason); } else { doCommit(reason); }
  }
  function scheduleCommit(waitMs, reason=""){
    if(commitRequested && pendingCommitTimer){ return; }
    commitRequested=true;
    pendingCommitTimer=setTimeout(()=>{ pendingCommitTimer=null; doCommit(reason+"(delayed)"); }, Math.ceil(waitMs));
  }
  function doCommit(reason=""){
    try{
      if(!dc) return;
      dc.send(JSON.stringify({ type:"input_audio_buffer.commit" }));
      lastCommitTs = performance.now();
      metrics.commits++;
      commitRequested=false;
      // log(`Â· commit ${reason}`, "muted");
    }catch(e){ commitRequested=false; }
  }

  // â€”â€” è‡ªé€‚åº”æ§åˆ¶å™¨ â€”â€” //
  function adaptOnce(){
    const now = performance.now();
    const spanSec = Math.max((now - metrics.lastEval)/1000, 0.001);
    const cps = metrics.commits / spanSec;                // commit é¢‘ç‡
    const avgChars = metrics.finals ? (metrics.finalChars / metrics.finals) : 0;

    // ç›®æ ‡åŒºé—´ï¼šavgChars â‰ˆ 55â€“85ï¼Œcommit é¢‘ç‡ â‰ˆ 0.3â€“0.6 /s
    let changed = false;

    // 1) ç‰‡æ®µå¤ªçŸ­ æˆ– commit è¿‡å¿« â†’ ç¨å¾®æ‹‰é•¿
    if ((avgChars && avgChars < 50) || cps > 0.65) {
      cfg.softPause = clamp(cfg.softPause + 50, 300, 900);
      cfg.hardPause = clamp(cfg.hardPause + 120, 900, 2200);
      cfg.minCommitChars = clamp(cfg.minCommitChars + 2, 10, 28);
      cfg.commitCooldownMs = clamp(cfg.commitCooldownMs + 40, 240, 700);
      cfg.rtVadPreset.silence_duration_ms = clamp(cfg.rtVadPreset.silence_duration_ms + 80, 600, 1200);
      changed = true;
      log(`ğŸ§­ è‡ªé€‚åº”ï¼šå¥å­åçŸ­ â†’ soft=${cfg.softPause}, hard=${cfg.hardPause}, minChars=${cfg.minCommitChars}, cooldown=${cfg.commitCooldownMs}, silence=${cfg.rtVadPreset.silence_duration_ms}`);
    }

    // 2) ç‰‡æ®µå¤ªé•¿ æˆ– commit å¤ªæ…¢ â†’ ç¨å¾®å˜å¿«
    else if ((avgChars && avgChars > 95) || cps < 0.25) {
      cfg.softPause = clamp(cfg.softPause - 50, 300, 900);
      cfg.hardPause = clamp(cfg.hardPause - 120, 900, 2200);
      cfg.minCommitChars = clamp(cfg.minCommitChars - 2, isIOS?14:10, 28);
      cfg.commitCooldownMs = clamp(cfg.commitCooldownMs - 40, isIOS?320:240, 700);
      cfg.rtVadPreset.silence_duration_ms = clamp(cfg.rtVadPreset.silence_duration_ms - 80, isIOS?750:650, 1200);
      changed = true;
      log(`ğŸ§­ è‡ªé€‚åº”ï¼šå¥å­åé•¿ â†’ soft=${cfg.softPause}, hard=${cfg.hardPause}, minChars=${cfg.minCommitChars}, cooldown=${cfg.commitCooldownMs}, silence=${cfg.rtVadPreset.silence_duration_ms}`);
    }

    // 3) æœ€è¿‘å‡ºç°è¿‡ buffer too small â†’ ç¨³ä¸€ç¨³
    if (metrics.tooSmallErrors > 0) {
      cfg.minBufferedBeforeCommitMs = clamp(cfg.minBufferedBeforeCommitMs + 20, 140, 220);
      changed = true;
      log(`ğŸ›¡ï¸ é˜²æŠ–ï¼šæå‡ minBuffered â†’ ${cfg.minBufferedBeforeCommitMs}ms`);
    } else {
      // å¾ˆç¨³çš„è¯å¯ç•¥å¾®ä¸‹é™ï¼Œæå‡å®æ—¶æ€§
      cfg.minBufferedBeforeCommitMs = clamp(cfg.minBufferedBeforeCommitMs - 10, 140, 220);
    }

    if (changed) sendSessionUpdate();  // æœåŠ¡ç«¯ VAD ä¹ŸåŒæ­¥
    // é‡ç½®çª—å£
    metrics.commits=0; metrics.finals=0; metrics.finalChars=0; metrics.tooSmallErrors=0; metrics.lastEval=now;
  }

  // â€”â€” ç¿»è¯‘ â€”â€” //
  function pickTargetLanguage(){
    if (cfg.translateTarget !== "auto") return cfg.translateTarget;
    if (cfg.langHint === "zh") return "de";
    if (cfg.langHint === "de" || cfg.langHint === "en") return "zh";
    return "en";
  }
  async function doLiveTranslate(text){
    const reqId=++liveTransReqId;
    try{
      const tgt=await translateText(text, pickTargetLanguage());
      if(reqId===liveTransReqId){ liveTgt=tgt; updatePreview(); }
    }catch(e){}
  }
  async function translateSegment(index){
    const src=finalPairs[index]?.src||""; if(!src) return;
    try{
      const tgt=await translateText(src, pickTargetLanguage());
      finalPairs[index].tgt=tgt; updatePreview();
    }catch(e){
      finalPairs[index].tgt="(ç¿»è¯‘å¤±è´¥ï¼š"+(e.message||"")+")"; updatePreview();
      log("âš ï¸ æ®µè½ç¿»è¯‘å¤±è´¥: "+e.message, "warn");
    }
  }
  async function translateText(text, targetLang){
    const resp=await fetch("https://api.openai.com/v1/chat/completions",{
      method:"POST",
      headers:{ "Authorization":`Bearer ${cfg.apiKey}`, "Content-Type":"application/json" },
      body: JSON.stringify({
        model:"gpt-4o-mini", temperature:0.2,
        messages:[
          { role:"system", content:
            `You are a high-quality, low-latency translator.
             Translate the user's text into ${targetLang}.
             Requirements: faithful, fluent, keep punctuation, no extra comments, no brackets, no quotes.
             If the text seems partial, still translate what's available.`},
          { role:"user", content:text }
        ]
      })
    });
    if(!resp.ok){ throw new Error("ç¿»è¯‘æ¥å£é”™è¯¯ï¼š"+await resp.text()); }
    const data=await resp.json();
    return (data?.choices?.[0]?.message?.content||"").trim();
  }

  // â€”â€” æ§åˆ¶ â€”â€” //
  function togglePause(){
    if(!micTrack) return;
    if(!paused){
      micTrack.enabled=false; paused=true;
      setStatus("å·²æš‚åœ Â· ä¸å†é‡‡é›†éŸ³é¢‘"); $("btnToggle").textContent="ç»§ç»­"; log("â¸ï¸ å·²æš‚åœéº¦å…‹é£");
    }else{
      micTrack.enabled=true; paused=false;
      firstAudioTs=performance.now(); startedStreaming=true;
      setStatus("å·²è¿æ¥ Â· æ­£åœ¨è½¬å†™â€¦"); $("btnToggle").textContent="æš‚åœ"; log("â–¶ï¸ ç»§ç»­é‡‡é›†éº¦å…‹é£");
    }
  }
  function copyPreview(){
    const text=$("preview").value||"";
    navigator.clipboard.writeText(text)
      .then(()=>log("ğŸ“‹ å·²å¤åˆ¶ï¼šé¢„è§ˆæ–‡æœ¬","ok"))
      .catch(e=>log("å¤åˆ¶å¤±è´¥: "+e.message,"warn"));
  }
  function stopAll(){ setStatus("å·²åœæ­¢"); log("â¹ï¸ åœæ­¢"); disableAll(false); cleanup(); }
  function disableAll(working){
    $("btnStart").disabled=working; $("btnToggle").disabled=true;
    $("btnStop").disabled=!working; $("btnCopyPreview").disabled=true;
  }
  function cleanup(){
    if(pendingCommitTimer){ clearTimeout(pendingCommitTimer); pendingCommitTimer=null; }
    if(fixedTimer){ clearInterval(fixedTimer); fixedTimer=null; }
    if(adaptTimer){ clearInterval(adaptTimer); adaptTimer=null; }
    if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
    try{ dc&&dc.close(); }catch{} try{ pc&&pc.close(); }catch{}
    try{ micTrack&&micTrack.stop(); }catch{}
    try{ micStream&&micStream.getTracks().forEach(t=>t.stop()); }catch{}
    if(ac){ try{ ac.close(); }catch{} ac=null; }
    pc=dc=micTrack=micStream=analyser=null; ephemeralKey=null; paused=false;
    speaking=false; noiseFloor=0; dynHigh=0; dynLow=0;
    firstAudioTs=0; lastCommitTs=0; startedStreaming=false; commitRequested=false;
    finalPairs.length=0; liveSrc=""; liveTgt=""; updatePreview();
  }

  // â€”â€” å°å·¥å…· â€”â€” //
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

})();
</script>
</body>
</html>
